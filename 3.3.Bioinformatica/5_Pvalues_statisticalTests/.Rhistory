data,
delta.table,
min.foldchange = 1.5)
datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
siggenes.table <- samr.compute.siggenes.table(samr.obj,
delta,
data,
delta.table,
min.foldchange = 1.5)
# datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
siggenes.table
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.2,][1,]
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.01,][1,]
samr.plot(samr.obj, delta)  # Check SAM plot
siggenes.table <- samr.compute.siggenes.table(samr.obj,
delta,
data,
delta.table,
min.foldchange = 1.5)
# datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
selected <- grep("mock|low virulent influenza A", pData(eset)$infection) # Select indexes
pData(eset)$infection[selected] # Check selection
y <- c(rep(1, 6), rep(2, 6))  # Vector of levels ID
y
# Get a subset of expression values of the selected samples
exprs.selected <- exprs(eset)[, selected]
plot.densities(exprs.selected, main = "BEFORE quantile.normalization", legend.pos="topright")
# p values before quantile normalize
pval = calPvalues(exprs.selected,y)
delta <- 2 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.1,][1,]
delta <- 1 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.1,][1,]
samr.plot(samr.obj, delta)  # Check SAM plot
delta <- 1.5 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
delta <- 1.4 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
delta <- 1.3 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
delta <- 1.2 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.1,][1,]
siggenes.table <- samr.compute.siggenes.table(samr.obj,
delta,
data,
delta.table,
min.foldchange = 1.5)
datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
siggenes.table
siggenes.table <- samr.compute.siggenes.table(samr.obj,
delta,
data,
delta.table,
min.foldchange = delta)
datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Turn off scientific notation like 1e+06
# options(scipen=999)
# Load Libs
library(DT)
library(samr)
library(affy)
library(GEOquery)
library(biomaRt)
library(Biobase)
library(limma)
library(affy)
library(siggenes)
library(PerformanceAnalytics)
source("./statistical_tests_lib.R")
getPvalues <- function(dist) {
ns = 2:200
ttest_pval = c()
wtest_pval = c()
ktest_pval = c()
for (n in ns) {
if (dist == "rnorm") {
vectorA = rnorm(n = n, mean = 1, sd = 1)
vectorB = rnorm(n = n, mean = 2, sd = 1)
} else {
vectorA = runif(n, -1, 1)
vectorB = runif(n, -1, 1)
}
if (n == max(ns)) {
plot.densities(vectorA, vectorB, main = paste0("n = ", n))
}
ttest = t.test(vectorA, vectorB)
ttest_pval = c(ttest_pval, ttest$p.value)
#print(ttest$p.value)
wtest = wilcox.test(vectorA, vectorB)
wtest_pval = c(wtest_pval, wtest$p.value)
#print(wtest$p.value)
ktest = ks.test(vectorA, vectorB)
ktest_pval = c(ktest_pval, ktest$p.value)
#print(ktest$p.value)
}
if (dist == "rnorm") {
plot(
ns,
ttest_pval,
main = "rnorm",
xlab = "n",
ylab = "p.value",
type = "l",
col = "blue",
log = "x"
)
} else {
plot(
ns,
ttest_pval,
main = "runif",
xlab = "n",
ylab = "p.value",
type = "l",
col = "blue"
)
}
lines(ns, wtest_pval,
col = "red")
lines(ns, ktest_pval,
col = "green")
legend("topright",
c("t.test", "wilcox.test", "ks.test"),
fill = c("blue", "red", "green"))
}
getPvalues("rnorm")
getPvalues("runif")
calPvalues <- function(data.matrix, lvls) {
pval = de.test(
x = data.matrix,
classes = lvls,
test = c("ttest", "kolmogorov", "wilcoxon")
)
data.matrix_sam <- sam(data.matrix,
c(rep(1, dim(data.matrix)[2])),
method = "d.stat",
gene.names = colnames(data.matrix))
return(
list(
"ttest_pval" = pval$ttest,
"wtest_pval" = pval$kolmogorov,
"ktest_pval" = pval$wilcoxon,
"sam_pval"   = unname(data.matrix_sam@p.value)
)
}
plt_pval <- function(pval) {
for (i in 1:length(pval)) {
ns = 1:length(pval[[i]])
plot(
ns,
pval[[i]],
main = "runif",
xlab = "",
ylab = "p.value",
#log = "y",
col = "blue",
type = "p"
)
}
# Download GDS file, put it in the current directory, and load it
gds5159 <- getGEO('GDS5159', destdir='./NCBI_GEO')
eset <- GDS2eSet(gds5159, do.log2 = TRUE)  # Convert the data to ESET object
pData(eset)$infection         # Let's check at the infections
table(pData(eset)$infection)  # No. of samples in each infection
selected <- grep("mock|highly virulent influenza A", pData(eset)$infection) # Select indexes
pData(eset)$infection[selected] # Check selection
y <- c(rep(1, 6), rep(2, 6))  # Vector of levels ID
y
# Get a subset of expression values of the selected samples
exprs.selected <- exprs(eset)[, selected]
plot.densities(exprs.selected, main = "BEFORE quantile.normalization", legend.pos="topright")
# p values before quantile normalize
pval = calPvalues(exprs.selected,y)
exprs.selected.q <- normalizeQuantiles(exprs.selected)  # Quantile normalize the data
plot.densities(exprs.selected.q, main = "AFTER quantile.normalization", legend.pos="topright")
# p values after quantile normalize
pval.q = calPvalues(exprs.selected.q,y)
chart.Correlation(
cbind(
ttest = pval.q$ttest_pval,
wtest = pval.q$wtest_pval,
ktest = pval.q$ktest_pval,
sam   = pval.q$sam_pval
),
histogram = TRUE
)
# Get row names = gene names or IDs
genenames <- rownames(exprs(eset))
data <- list(
x = exprs.selected.q,
y = y,
geneid = genenames,
genenames = genenames,
logged2 = TRUE
)
# Get object names from samr.obj
samr.obj <-
samr(data, resp.type = "Two class unpaired", nperms = 100)
names(samr.obj)
delta <- 1.2 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.1,][1,]
samr.plot(samr.obj, delta)  # Check SAM plot
siggenes.table <- samr.compute.siggenes.table(samr.obj,
delta,
data,
delta.table,
min.foldchange = delta)
datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
# Download GDS file, put it in the current directory, and load it
gds858 <- getGEO('GDS858', destdir='./NCBI_GEO')
eset <- GDS2eSet(gds858, do.log2 = TRUE)  # Convert the data to ESET object
pData(eset)$infection         # Let's check at the infections
table(pData(eset)$infection)  # No. of samples in each infection
selected <- grep("uninfected|FRD440", pData(eset)$infection) # Select indexes
pData(eset)$infection[selected]                              # Check selection
y <- c(rep(1, 4), rep(2, 4))  # Vector of levels ID
y
# Get a subset of expression values of the selected samples
exprs.selected <- exprs(eset)[, selected]
plot.densities(exprs.selected, main = "BEFORE quantile.normalization")
# p values before quantile normalize
pval = calPvalues(exprs.selected,y)
exprs.selected.q <- normalizeQuantiles(exprs.selected)  # Quantile normalize the data
plot.densities(exprs.selected.q, main = "AFTER quantile.normalization")
# p values after quantile normalize
pval.q = calPvalues(exprs.selected.q,y)
chart.Correlation(
cbind(
ttest = pval.q$ttest_pval,
wtest = pval.q$wtest_pval,
ktest = pval.q$ktest_pval,
sam   = pval.q$sam_pval
),
histogram = TRUE
)
# Get row names = gene names or IDs
genenames <- rownames(exprs(eset))
data <- list(
x = exprs.selected.q,
y = y,
geneid = genenames,
genenames = genenames,
logged2 = TRUE
)
# Get object names from samr.obj
samr.obj <-
samr(data, resp.type = "Two class unpaired", nperms = 100)
names(samr.obj)
delta <- 1.9 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.1,][1,]
samr.plot(samr.obj, delta)  # Check SAM plot
# Summarize
siggenes.table <- samr.compute.siggenes.table(samr.obj,
delta,
data,
delta.table,
min.foldchange = delta)
datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
# Enable Warning messages
options(warn = 0)
chart.Correlation(
exprs.selected,
histogram = TRUE
)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Turn off scientific notation like 1e+06
# options(scipen=999)
# Load Libs
library(DT)
library(samr)
library(affy)
library(GEOquery)
library(biomaRt)
library(Biobase)
library(limma)
library(affy)
library(siggenes)
library(PerformanceAnalytics)
source("./statistical_tests_lib.R")
getPvalues <- function(dist) {
ns = 2:200
ttest_pval = c()
wtest_pval = c()
ktest_pval = c()
for (n in ns) {
if (dist == "rnorm") {
vectorA = rnorm(n = n, mean = 1, sd = 1)
vectorB = rnorm(n = n, mean = 2, sd = 1)
} else {
vectorA = runif(n, -1, 1)
vectorB = runif(n, -1, 1)
}
if (n == max(ns)) {
plot.densities(vectorA, vectorB, main = paste0("n = ", n))
}
ttest = t.test(vectorA, vectorB)
ttest_pval = c(ttest_pval, ttest$p.value)
#print(ttest$p.value)
wtest = wilcox.test(vectorA, vectorB)
wtest_pval = c(wtest_pval, wtest$p.value)
#print(wtest$p.value)
ktest = ks.test(vectorA, vectorB)
ktest_pval = c(ktest_pval, ktest$p.value)
#print(ktest$p.value)
}
if (dist == "rnorm") {
plot(
ns,
ttest_pval,
main = "rnorm",
xlab = "n",
ylab = "p.value",
type = "l",
col = "blue",
log = "x"
)
} else {
plot(
ns,
ttest_pval,
main = "runif",
xlab = "n",
ylab = "p.value",
type = "l",
col = "blue"
)
}
lines(ns, wtest_pval,
col = "red")
lines(ns, ktest_pval,
col = "green")
legend("topright",
c("t.test", "wilcox.test", "ks.test"),
fill = c("blue", "red", "green"))
}
getPvalues("rnorm")
getPvalues("runif")
calPvalues <- function(data.matrix, lvls) {
pval = de.test(
x = data.matrix,
classes = lvls,
test = c("ttest", "kolmogorov", "wilcoxon")
)
data.matrix_sam <- sam(data.matrix,
c(rep(1, dim(data.matrix)[2])),
method = "d.stat",
gene.names = colnames(data.matrix))
return(
list(
"ttest_pval" = pval$ttest,
"wtest_pval" = pval$kolmogorov,
"ktest_pval" = pval$wilcoxon,
"sam_pval"   = unname(data.matrix_sam@p.value)
)
}
plt_pval <- function(pval) {
for (i in 1:length(pval)) {
ns = 1:length(pval[[i]])
plot(
ns,
pval[[i]],
main = "runif",
xlab = "",
ylab = "p.value",
#log = "y",
col = "blue",
type = "p"
)
}
# Download GDS file, put it in the current directory, and load it
gds5159 <- getGEO('GDS5159', destdir='./NCBI_GEO')
eset <- GDS2eSet(gds5159, do.log2 = TRUE)  # Convert the data to ESET object
pData(eset)$infection         # Let's check at the infections
table(pData(eset)$infection)  # No. of samples in each infection
selected <- grep("mock|highly virulent influenza A", pData(eset)$infection) # Select indexes
pData(eset)$infection[selected] # Check selection
y <- c(rep(1, 6), rep(2, 6))  # Vector of levels ID
y
# Get a subset of expression values of the selected samples
exprs.selected <- exprs(eset)[, selected]
plot.densities(exprs.selected, main = "BEFORE quantile.normalization", legend.pos="topright")
# p values before quantile normalize
pval = calPvalues(exprs.selected,y)
exprs.selected.q <- normalizeQuantiles(exprs.selected)  # Quantile normalize the data
plot.densities(exprs.selected.q, main = "AFTER quantile.normalization", legend.pos="topright")
# p values after quantile normalize
pval.q = calPvalues(exprs.selected.q,y)
chart.Correlation(
exprs.selected.q,
histogram = TRUE
)
# Get row names = gene names or IDs
genenames <- rownames(exprs(eset))
data <- list(
x = exprs.selected.q,
y = y,
geneid = genenames,
genenames = genenames,
logged2 = TRUE
)
# Get object names from samr.obj
samr.obj <-
samr(data, resp.type = "Two class unpaired", nperms = 100)
names(samr.obj)
delta <- 1.2 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.1,][1,]
samr.plot(samr.obj, delta)  # Check SAM plot
siggenes.table <- samr.compute.siggenes.table(samr.obj,
delta,
data,
delta.table,
min.foldchange = delta)
datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
# Download GDS file, put it in the current directory, and load it
gds858 <- getGEO('GDS858', destdir='./NCBI_GEO')
eset <- GDS2eSet(gds858, do.log2 = TRUE)  # Convert the data to ESET object
pData(eset)$infection         # Let's check at the infections
table(pData(eset)$infection)  # No. of samples in each infection
selected <- grep("uninfected|FRD440", pData(eset)$infection) # Select indexes
pData(eset)$infection[selected]                              # Check selection
y <- c(rep(1, 4), rep(2, 4))  # Vector of levels ID
y
# Get a subset of expression values of the selected samples
exprs.selected <- exprs(eset)[, selected]
plot.densities(exprs.selected, main = "BEFORE quantile.normalization")
# p values before quantile normalize
pval = calPvalues(exprs.selected,y)
exprs.selected.q <- normalizeQuantiles(exprs.selected)  # Quantile normalize the data
plot.densities(exprs.selected.q, main = "AFTER quantile.normalization")
# p values after quantile normalize
pval.q = calPvalues(exprs.selected.q,y)
chart.Correlation(
exprs.selected.q,
histogram = TRUE
)
# Get row names = gene names or IDs
genenames <- rownames(exprs(eset))
data <- list(
x = exprs.selected.q,
y = y,
geneid = genenames,
genenames = genenames,
logged2 = TRUE
)
# Get object names from samr.obj
samr.obj <-
samr(data, resp.type = "Two class unpaired", nperms = 100)
names(samr.obj)
delta <- 1.9 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
# Look at the whole delta table
datatable(delta.table)
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.1,][1,]
samr.plot(samr.obj, delta)  # Check SAM plot
# Summarize
siggenes.table <- samr.compute.siggenes.table(samr.obj,
delta,
data,
delta.table,
min.foldchange = delta)
datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
# Enable Warning messages
options(warn = 0)
