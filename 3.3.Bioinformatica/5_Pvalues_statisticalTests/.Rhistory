})
vd_ctrl_ktest
# # Perform the stat tests
# t.test(ex_log2[,which(compare_groups == "control")],ex_log2[,which(compare_groups == "sars")])
# wilcox.test(ex_log2[,which(compare_groups == "control")],ex_log2[,which(compare_groups == "sars")])
# ks.test(ex_log2[,which(compare_groups == "control")],ex_log2[,which(compare_groups == "sars")])
# dm_all_sam = sam(dm_all, c(rep(1, 4), rep(0, 10)), method = "d.stat")
calPvalues <- function(data.matrix) {
pval = de.test(
x = data.matrix,
classes = c(rep(1, 4), rep(0, 10)),
test = c("ttest", "kolmogorov", "wilcoxon")
)
data.matrix_sam <- sam(data.matrix,
c(rep(1, dim(data.matrix)[2])),
method = "d.stat",
gene.names = colnames(data.matrix))
return(
list(
"ttest_pval" = pval$ttest,
"wtest_pval" = pval$kolmogorov,
"ktest_pval" = pval$wilcoxon,
"sam_pval"   = unname(data.matrix_sam@p.value)
)
# #Mostrar resultados de SAM con cierto valor de delta
# data.matrix_sam_sum <- summary(data.matrix_sam, 1.9)
#
# #Acceder a matrix de Genes significativos
# dim(data.matrix_sam_sum@mat.sig)
}
plt_pval <- function(pval) {
for (i in 1:length(pval)) {
ns = 1:length(pval[[i]])
plot(
ns,
pval[[i]],
main = "runif",
xlab = "",
ylab = "p.value",
#log = "y",
col = "blue",
type = "p"
)
}
# lines(ns, ttest_pval,
#       col = "red",
#       type = "p")
#
# lines(ns, wtest_pval,
#       col = "green",
#       type = "p")
#
# lines(ns, ktest_pval,
#       col = "magenta",
#       type = "p")
#
# legend(
#   "topright",
#   c("sam", "t.test", "wilcox.test", "ks.test"),
#   fill = c("blue", "red", "green", "magenta")
# )
pval = calPvalues(dm_all)
plot(
pval$ttest_pval,
pval$sam_pval,
main = "runif",
xlab = "",
ylab = "p.value",
#log = "y",
col = "blue",
type = "p"
)
pval_qn = calPvalues(data.matrix_qn)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Turn off scientific notation like 1e+06
# options(scipen=999)
# Load Libs
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
library(siggenes)
source("./statistical_tests_lib.R")
getPvalues <- function(dist) {
ns = 2:200
ttest_pval = c()
wtest_pval = c()
ktest_pval = c()
for (n in ns) {
if (dist == "rnorm") {
vectorA = rnorm(n = n, mean = 1, sd = 1)
vectorB = rnorm(n = n, mean = 2, sd = 1)
} else {
vectorA = runif(n, -1, 1)
vectorB = runif(n, -1, 1)
}
if (n == max(ns)) {
plot.densities(vectorA, vectorB, main = paste0("n = ", n))
}
ttest = t.test(vectorA, vectorB)
ttest_pval = c(ttest_pval, ttest$p.value)
#print(ttest$p.value)
wtest = wilcox.test(vectorA, vectorB)
wtest_pval = c(wtest_pval, wtest$p.value)
#print(wtest$p.value)
ktest = ks.test(vectorA, vectorB)
ktest_pval = c(ktest_pval, ktest$p.value)
#print(ktest$p.value)
}
if (dist == "rnorm") {
plot(
ns,
ttest_pval,
main = "rnorm",
xlab = "n",
ylab = "p.value",
type = "l",
col = "blue",
log = "x"
)
} else {
plot(
ns,
ttest_pval,
main = "runif",
xlab = "n",
ylab = "p.value",
type = "l",
col = "blue"
)
}
lines(ns, wtest_pval,
col = "red")
lines(ns, ktest_pval,
col = "green")
legend("topright",
c("t.test", "wilcox.test", "ks.test"),
fill = c("blue", "red", "green"))
}
getPvalues("rnorm")
getPvalues("runif")
databaseID = "GSE1739"
gse <- getGEO(databaseID, GSEMatrix = FALSE, destdir = "./NCBI_GEO")
# names of all the GSM objects contained in the GSE
lst_gsm = GSMList(gse)
names(lst_gsm)
# and get the 1st GSM object on the list
lst_gsm[[1]]
# and the names of the GPLs represented
lst_gpl = GPLList(gse)
names(lst_gpl)
gsmplatforms <- lapply(lst_gsm, function(x) {
Meta(x)$platform_id
})
length(gsmplatforms)
# If there are more GPLs, we can filter the original GSMList to include only those GSMs within
# a specific platform and use this list for further processing
gsmlist = Filter(function(gsm) {
Meta(gsm)$platform_id == 'GPL201'
},
GSMList(gse))
length(gsmlist)
Table(gsmlist[[1]])[1:5, ]
gset = getGEO(databaseID, GSEMatrix = TRUE, destdir = "./NCBI_GEO")[[1]][1]
pD_gset = pData(phenoData(gset))
pD_gset[,c(1,12)]
#We will indeed use the VALUE column. We then want to make a matrix of these values like so:
# get the probeset ordering
probesets <- Table(GPLList(gse)[[1]])$ID
# make the data matrix from the VALUE columns from each GSM
# being careful to match the order of the probesets in the platform
# with those in the GSMs
data.matrix <- do.call('cbind', lapply(gsmlist, function(x)
{
tab <- Table(x)
mymatch <-
match(probesets, tab$ID_REF)
return(tab$VALUE[mymatch])
}))
data.matrix <-
apply(data.matrix, 2, function(x) {
as.numeric(as.character(x))
})
dm_all <- log2(data.matrix)
# Normal (control) samples
dm_norm = dm_all[1:5,1:4]
dm_norm
# SARS samples
dm_sars = dm_all[1:5,5:14]
dm_sars
plot.densities(dm_all,  main = "BEFORE quantile.normalization()")
dm_all_qn <- quantile.normalization(dm_all)
# Normal (control) samples
dm_norm_qn = dm_all_qn[1:5,1:4]
dm_norm_qn
# SARS samples
dm_sars_qn = dm_all_qn[1:5,5:14]
dm_sars_qn
plot.densities(dm_all_qn, main = "AFTER quantile.normalization()")
compare_groups = c(rep("control", 4), rep("sars", 10))
ex = exprs(gset)
ex_log2 = log2(ex + 1)
cbind(compare_groups, ex_log2[,])
print("")
# # Perform the stat tests
# vd_ctrl_ttest = apply(ex_log2,1,function(x){
#   aux = t.test(x[which(compare_groups == "control")],x[which(compare_groups == "sars")])
#   aux$p.value
# })
# vd_ctrl_ttest
# vd_ctrl_wtest = apply(ex_log2,1,function(x){
#   aux = wilcox.test(x[which(compare_groups == "control")],x[which(compare_groups == "sars")])
#   aux$p.value
# })
# vd_ctrl_wtest
# vd_ctrl_ktest = apply(ex_log2,1,function(x){
#   aux = ks.test(x[which(compare_groups == "control")],x[which(compare_groups == "sars")])
#   aux$p.value
# })
# vd_ctrl_ktest
# # Perform the stat tests
# t.test(ex_log2[,which(compare_groups == "control")],ex_log2[,which(compare_groups == "sars")])
# wilcox.test(ex_log2[,which(compare_groups == "control")],ex_log2[,which(compare_groups == "sars")])
# ks.test(ex_log2[,which(compare_groups == "control")],ex_log2[,which(compare_groups == "sars")])
# dm_all_sam = sam(dm_all, c(rep(1, 4), rep(0, 10)), method = "d.stat")
calPvalues <- function(data.matrix) {
pval = de.test(
x = data.matrix,
classes = c(rep(1, 4), rep(0, 10)),
test = c("ttest", "kolmogorov", "wilcoxon")
)
data.matrix_sam <- sam(data.matrix,
c(rep(1, dim(data.matrix)[2])),
method = "d.stat",
gene.names = colnames(data.matrix))
return(
list(
"ttest_pval" = pval$ttest,
"wtest_pval" = pval$kolmogorov,
"ktest_pval" = pval$wilcoxon,
"sam_pval"   = unname(data.matrix_sam@p.value)
)
# #Mostrar resultados de SAM con cierto valor de delta
# data.matrix_sam_sum <- summary(data.matrix_sam, 1.9)
#
# #Acceder a matrix de Genes significativos
# dim(data.matrix_sam_sum@mat.sig)
}
plt_pval <- function(pval) {
for (i in 1:length(pval)) {
ns = 1:length(pval[[i]])
plot(
ns,
pval[[i]],
main = "runif",
xlab = "",
ylab = "p.value",
#log = "y",
col = "blue",
type = "p"
)
}
# lines(ns, ttest_pval,
#       col = "red",
#       type = "p")
#
# lines(ns, wtest_pval,
#       col = "green",
#       type = "p")
#
# lines(ns, ktest_pval,
#       col = "magenta",
#       type = "p")
#
# legend(
#   "topright",
#   c("sam", "t.test", "wilcox.test", "ks.test"),
#   fill = c("blue", "red", "green", "magenta")
# )
pval = calPvalues(dm_all)
plot(
pval$ttest_pval,
pval$sam_pval,
main = "runif",
xlab = "",
ylab = "p.value",
#log = "y",
col = "blue",
type = "p"
)
pval_qn = calPvalues(dm_all_qn)
plot(cars)
# Enable Warning messages
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Turn off scientific notation like 1e+06
# options(scipen=999)
# Load Libs
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
library(siggenes)
source("./statistical_tests_lib.R")
getPvalues <- function(dist) {
ns = 2:200
ttest_pval = c()
wtest_pval = c()
ktest_pval = c()
for (n in ns) {
if (dist == "rnorm") {
vectorA = rnorm(n = n, mean = 1, sd = 1)
vectorB = rnorm(n = n, mean = 2, sd = 1)
} else {
vectorA = runif(n, -1, 1)
vectorB = runif(n, -1, 1)
}
if (n == max(ns)) {
plot.densities(vectorA, vectorB, main = paste0("n = ", n))
}
ttest = t.test(vectorA, vectorB)
ttest_pval = c(ttest_pval, ttest$p.value)
#print(ttest$p.value)
wtest = wilcox.test(vectorA, vectorB)
wtest_pval = c(wtest_pval, wtest$p.value)
#print(wtest$p.value)
ktest = ks.test(vectorA, vectorB)
ktest_pval = c(ktest_pval, ktest$p.value)
#print(ktest$p.value)
}
if (dist == "rnorm") {
plot(
ns,
ttest_pval,
main = "rnorm",
xlab = "n",
ylab = "p.value",
type = "l",
col = "blue",
log = "x"
)
} else {
plot(
ns,
ttest_pval,
main = "runif",
xlab = "n",
ylab = "p.value",
type = "l",
col = "blue"
)
}
lines(ns, wtest_pval,
col = "red")
lines(ns, ktest_pval,
col = "green")
legend("topright",
c("t.test", "wilcox.test", "ks.test"),
fill = c("blue", "red", "green"))
}
getPvalues("rnorm")
getPvalues("runif")
databaseID = "GSE1739"
gse <- getGEO(databaseID, GSEMatrix = FALSE, destdir = "./NCBI_GEO")
# names of all the GSM objects contained in the GSE
lst_gsm = GSMList(gse)
names(lst_gsm)
# and get the 1st GSM object on the list
lst_gsm[[1]]
# and the names of the GPLs represented
lst_gpl = GPLList(gse)
names(lst_gpl)
gsmplatforms <- lapply(lst_gsm, function(x) {
Meta(x)$platform_id
})
length(gsmplatforms)
# If there are more GPLs, we can filter the original GSMList to include only those GSMs within
# a specific platform and use this list for further processing
gsmlist = Filter(function(gsm) {
Meta(gsm)$platform_id == 'GPL201'
},
GSMList(gse))
length(gsmlist)
Table(gsmlist[[1]])[1:5, ]
gset = getGEO(databaseID, GSEMatrix = TRUE, destdir = "./NCBI_GEO")[[1]][1]
pD_gset = pData(phenoData(gset))
pD_gset[,c(1,12)]
#We will indeed use the VALUE column. We then want to make a matrix of these values like so:
# get the probeset ordering
probesets <- Table(GPLList(gse)[[1]])$ID
# make the data matrix from the VALUE columns from each GSM
# being careful to match the order of the probesets in the platform
# with those in the GSMs
data.matrix <- do.call('cbind', lapply(gsmlist, function(x)
{
tab <- Table(x)
mymatch <-
match(probesets, tab$ID_REF)
return(tab$VALUE[mymatch])
}))
data.matrix <-
apply(data.matrix, 2, function(x) {
as.numeric(as.character(x))
})
dm_all <- log2(data.matrix)
# Normal (control) samples
dm_norm = dm_all[1:5,1:4]
dm_norm
# SARS samples
dm_sars = dm_all[1:5,5:14]
dm_sars
plot.densities(dm_all,  main = "BEFORE quantile.normalization()")
dm_all_qn <- quantile.normalization(dm_all)
# Normal (control) samples
dm_norm_qn = dm_all_qn[1:5,1:4]
dm_norm_qn
# SARS samples
dm_sars_qn = dm_all_qn[1:5,5:14]
dm_sars_qn
plot.densities(dm_all_qn, main = "AFTER quantile.normalization()")
compare_groups = c(rep("control", 4), rep("sars", 10))
ex = exprs(gset)
ex_log2 = log2(ex + 1)
cbind(compare_groups, ex_log2[,])
print("")
# # Perform the stat tests
# vd_ctrl_ttest = apply(ex_log2,1,function(x){
#   aux = t.test(x[which(compare_groups == "control")],x[which(compare_groups == "sars")])
#   aux$p.value
# })
# vd_ctrl_ttest
# vd_ctrl_wtest = apply(ex_log2,1,function(x){
#   aux = wilcox.test(x[which(compare_groups == "control")],x[which(compare_groups == "sars")])
#   aux$p.value
# })
# vd_ctrl_wtest
# vd_ctrl_ktest = apply(ex_log2,1,function(x){
#   aux = ks.test(x[which(compare_groups == "control")],x[which(compare_groups == "sars")])
#   aux$p.value
# })
# vd_ctrl_ktest
# # Perform the stat tests
# t.test(ex_log2[,which(compare_groups == "control")],ex_log2[,which(compare_groups == "sars")])
# wilcox.test(ex_log2[,which(compare_groups == "control")],ex_log2[,which(compare_groups == "sars")])
# ks.test(ex_log2[,which(compare_groups == "control")],ex_log2[,which(compare_groups == "sars")])
# dm_all_sam = sam(dm_all, c(rep(1, 4), rep(0, 10)), method = "d.stat")
calPvalues <- function(data.matrix) {
pval = de.test(
x = data.matrix,
classes = c(rep(1, 4), rep(0, 10)),
test = c("ttest", "kolmogorov", "wilcoxon")
)
data.matrix_sam <- sam(data.matrix,
c(rep(1, dim(data.matrix)[2])),
method = "d.stat",
gene.names = colnames(data.matrix))
return(
list(
"ttest_pval" = pval$ttest,
"wtest_pval" = pval$kolmogorov,
"ktest_pval" = pval$wilcoxon,
"sam_pval"   = unname(data.matrix_sam@p.value)
)
# #Mostrar resultados de SAM con cierto valor de delta
# data.matrix_sam_sum <- summary(data.matrix_sam, 1.9)
#
# #Acceder a matrix de Genes significativos
# dim(data.matrix_sam_sum@mat.sig)
}
# [TODO: make correlation matrix plot w/individual plots for each]
plt_pval <- function(pval) {
for (i in 1:length(pval)) {
ns = 1:length(pval[[i]])
plot(
ns,
pval[[i]],
main = "runif",
xlab = "",
ylab = "p.value",
#log = "y",
col = "blue",
type = "p"
)
}
# lines(ns, ttest_pval,
#       col = "red",
#       type = "p")
#
# lines(ns, wtest_pval,
#       col = "green",
#       type = "p")
#
# lines(ns, ktest_pval,
#       col = "magenta",
#       type = "p")
#
# legend(
#   "topright",
#   c("sam", "t.test", "wilcox.test", "ks.test"),
#   fill = c("blue", "red", "green", "magenta")
# )
pval = calPvalues(dm_all)
pval_qn = calPvalues(dm_all_qn)
plot(cars)
# Enable Warning messages
options(warn = 0)
