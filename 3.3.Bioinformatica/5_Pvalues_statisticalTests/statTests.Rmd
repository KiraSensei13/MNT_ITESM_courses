---
title: "Statistical Tests"
author: "Antonio Osamu Katagiri Tanaka - A01212611@itesm.mx"
date: March 27, 2020
output:
  pdf_document: default
  html_notebook: default
classoption: a4paper
geometry: margin=1.75cm
always_allow_html: true
---

```{r}
# Clear all objects (from the workspace)
rm(list = ls())

# Suppress Warning messages
options(warn = -1)

# Turn off scientific notation like 1e+06
# options(scipen=999)

# Load Libs
library(DT)
library(samr)
library(affy)
library(GEOquery)
library(biomaRt)
library(Biobase)
library(limma)
library(affy)
library(siggenes)
library(PerformanceAnalytics)
source("./statistical_tests_lib.R")
```

---

---

# 1) Obtener p-values con un t-test, Wilcoxon y Kolmogorov para:

## A) 2 vectores de datos con distribución normal (rnorm) y diferente media, para número de muestras n= 2……20. Graficar los resultados y comparar.

```{r}
getPvalues <- function(dist) {
  ns = 2:200
  ttest_pval = c()
  wtest_pval = c()
  ktest_pval = c()
  
  for (n in ns) {
    if (dist == "rnorm") {
      vectorA = rnorm(n = n, mean = 1, sd = 1)
      vectorB = rnorm(n = n, mean = 2, sd = 1)
    } else {
      vectorA = runif(n, -1, 1)
      vectorB = runif(n, -1, 1)
    }
    
    if (n == max(ns)) {
      plot.densities(vectorA, vectorB, main = paste0("n = ", n))
    }
    
    ttest = t.test(vectorA, vectorB)
    ttest_pval = c(ttest_pval, ttest$p.value)
    #print(ttest$p.value)
    
    wtest = wilcox.test(vectorA, vectorB)
    wtest_pval = c(wtest_pval, wtest$p.value)
    #print(wtest$p.value)
    
    ktest = ks.test(vectorA, vectorB)
    ktest_pval = c(ktest_pval, ktest$p.value)
    #print(ktest$p.value)
  }
  
  if (dist == "rnorm") {
    plot(
      ns,
      ttest_pval,
      main = "rnorm",
      xlab = "n",
      ylab = "p.value",
      type = "l",
      col = "blue",
      log = "x"
    )
  } else {
    plot(
      ns,
      ttest_pval,
      main = "runif",
      xlab = "n",
      ylab = "p.value",
      type = "l",
      col = "blue"
    )
  }
  
  lines(ns, wtest_pval,
        col = "red")
  
  lines(ns, ktest_pval,
        col = "green")
  
  legend("topright",
         c("t.test", "wilcox.test", "ks.test"),
         fill = c("blue", "red", "green"))
}

getPvalues("rnorm")
```

## B) Repetir (A) con 2 vectores de datos generados con la función runif.

```{r}
getPvalues("runif")
```

---

---

# 2) Obtener p-values con un t-test, Wilcoxon, Kolmogorov y SAM para una base de datos GEO de su elección.

```{r}
calPvalues <- function(data.matrix, lvls) {
  pval = de.test(
    x = data.matrix,
    classes = lvls,
    test = c("ttest", "kolmogorov", "wilcoxon")
  )
  data.matrix_sam <- sam(data.matrix,
                         c(rep(1, dim(data.matrix)[2])),
                         method = "d.stat",
                         gene.names = colnames(data.matrix))
  
  return(
    list(
      "ttest_pval" = pval$ttest,
      "wtest_pval" = pval$kolmogorov,
      "ktest_pval" = pval$wilcoxon,
      "sam_pval"   = unname(data.matrix_sam@p.value)
    )
  )
}

plt_pval <- function(pval) {
  for (i in 1:length(pval)) {
    ns = 1:length(pval[[i]])
    plot(
      ns,
      pval[[i]],
      main = "runif",
      xlab = "",
      ylab = "p.value",
      #log = "y",
      col = "blue",
      type = "p"
    )
  }
}
```

---

### Dataset details

**Title:**	Lung response to highly virulent or low virulent influenza A H3N2 virus infection: time course

**Summary:**	Analysis of total lung from BALB/c females infected with highly virulent influenza A (HVI) or low virulent influenza A (LVI), up to 96 hrs following infection. Results provide insight into the molecular mechanisms underlying the host pulmonary responses to HVI and LVI infections.

**Organism:**	Mus musculus

**Platform:**	GPL6103: Illumina mouseRef-8 v1.1 expression beadchip

**Citation:**	Ivan FX, Rajapakse JC, Welsch RE, Rozen SG et al. Differential pulmonary transcriptomic profiles in murine lungs infected with low and highly virulent influenza H3N2 viruses reveal dysregulation of TREM1 signaling, cytokines, and chemokines. Funct Integr Genomics 2012 Mar;12(1):105-17. PMID: 21874528

**Reference Series:**	GSE55994

**Sample count:**	18

**Value type:**	transformed count

**Series published:**	2014/03/19

**Dataset taken from:** [ncbi.nlm.nih.gov](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE55994)

---

Let’s compare influenza A H3N2 infection levels. (from GSE55994)

```{r}
# Download GDS file, put it in the current directory, and load it
gds5159 <- getGEO('GDS5159', destdir='./NCBI_GEO')
eset <- GDS2eSet(gds5159, do.log2 = TRUE)  # Convert the data to ESET object
```

```{r}
pData(eset)$infection         # Let's check at the infections
table(pData(eset)$infection)  # No. of samples in each infection
```

Filter columns associated with 'highly virulent influenza A' and 'mock' values.

```{r}
selected <- grep("mock|highly virulent influenza A", pData(eset)$infection) # Select indexes
pData(eset)$infection[selected] # Check selection
```

'highly virulent influenza A' as '1's and 'mock' '2's

```{r}
y <- c(rep(1, 6), rep(2, 6))  # Vector of levels ID
y
```

## A) Verifique si necesita normalizar los datos con quantile normalization. Obtenga p-values antes y después de normalizar.

Filter the expression matrix according to selected, then quantile normalize

[There is small-to-large variability within groups and small variability across groups, so, let's use quantile normalization]

```{r}
# Get a subset of expression values of the selected samples
exprs.selected <- exprs(eset)[, selected]
plot.densities(exprs.selected, main = "BEFORE quantile.normalization", legend.pos="topright")
# p values before quantile normalize
pval = calPvalues(exprs.selected,y)

exprs.selected.q <- normalizeQuantiles(exprs.selected)  # Quantile normalize the data
plot.densities(exprs.selected.q, main = "AFTER quantile.normalization", legend.pos="topright")
# p values after quantile normalize
pval.q = calPvalues(exprs.selected.q,y)
```

## B) Compare los p-values y grafique. Comente sobre la correlación entre las distintas pruebas estadísticas y la cantidad de genes significativos.

```{r}
chart.Correlation(
  exprs.selected.q,
  histogram = TRUE
)
```

**In the above plot:**

* The distribution of each variable is shown on the diagonal.
* On the bottom of the diagonal : the bivariate scatter plots with a fitted line are displayed
* On the top of the diagonal : the value of the correlation plus the significance level as stars
* Each significance level is associated to a symbol : p-values(0, 0.001, 0.01, 0.05, 0.1, 1) <=> symbols(“***”, “**”, “*”, “.”, " “)


Let's prepare the data that required to run **samr()**

```{r}
# Get row names = gene names or IDs
genenames <- rownames(exprs(eset))
data <- list(
  x = exprs.selected.q,
  y = y,
  geneid = genenames,
  genenames = genenames,
  logged2 = TRUE
)
```

Refer to help(samr) for more info.

```{r}
# Get object names from samr.obj
samr.obj <-
  samr(data, resp.type = "Two class unpaired", nperms = 100)

names(samr.obj)
```

Compute thresholds for different deltas

```{r}
delta <- 1.2 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
```

```{r}
# Look at the whole delta table
datatable(delta.table)
```

Let’s select delta with median FDR <10%.

```{r}
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.1,][1,]
```

```{r}
samr.plot(samr.obj, delta)  # Check SAM plot
```

## B) Comente sobre la cantidad de genes significativos.

### Get significant genes

```{r}
siggenes.table <- samr.compute.siggenes.table(samr.obj,
                                              delta,
                                              data,
                                              delta.table,
                                              min.foldchange = delta)

datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
```

---

---

# 3) Repetir el ejercicio (2) pero con una base de datos de GEO con menos o más muestras, según sea el caso.

Let's compare lung cells related gene expressions due to different bacterial strains. (from GDS858=

```{r}
# Download GDS file, put it in the current directory, and load it
gds858 <- getGEO('GDS858', destdir='./NCBI_GEO')
eset <- GDS2eSet(gds858, do.log2 = TRUE)  # Convert the data to ESET object
```

```{r}
pData(eset)$infection         # Let's check at the infections
table(pData(eset)$infection)  # No. of samples in each infection
```

Filter columns associated with 'uninfected' and 'FRD440' values.

```{r}
selected <- grep("uninfected|FRD440", pData(eset)$infection) # Select indexes
pData(eset)$infection[selected]                              # Check selection
```

'Uninfected' as '1's and 'FRD440' '2's

```{r}
y <- c(rep(1, 4), rep(2, 4))  # Vector of levels ID
y
```

## A) Verifique si necesita normalizar los datos con quantile normalization. Obtenga p-values antes y después de normalizar.

Filter the expression matrix according to selected, then quantile normalize

[There is small-to-large variability within groups and small variability across groups, so, let's use quantile normalization]

```{r}
# Get a subset of expression values of the selected samples
exprs.selected <- exprs(eset)[, selected]
plot.densities(exprs.selected, main = "BEFORE quantile.normalization")
# p values before quantile normalize
pval = calPvalues(exprs.selected,y)

exprs.selected.q <- normalizeQuantiles(exprs.selected)  # Quantile normalize the data
plot.densities(exprs.selected.q, main = "AFTER quantile.normalization")
# p values after quantile normalize
pval.q = calPvalues(exprs.selected.q,y)
```

## B) Compare los p-values y grafique. Comente sobre la correlación entre las distintas pruebas estadísticas y la cantidad de genes significativos.

```{r}
chart.Correlation(
  exprs.selected.q,
  histogram = TRUE
)
```

**In the above plot:**

* The distribution of each variable is shown on the diagonal.
* On the bottom of the diagonal : the bivariate scatter plots with a fitted line are displayed
* On the top of the diagonal : the value of the correlation plus the significance level as stars
* Each significance level is associated to a symbol : p-values(0, 0.001, 0.01, 0.05, 0.1, 1) <=> symbols(“***”, “**”, “*”, “.”, " “)


Let's prepare the data that required to run **samr()**

```{r}
# Get row names = gene names or IDs
genenames <- rownames(exprs(eset))
data <- list(
  x = exprs.selected.q,
  y = y,
  geneid = genenames,
  genenames = genenames,
  logged2 = TRUE
)
```

Refer to help(samr) for more info.

```{r}
# Get object names from samr.obj
samr.obj <-
  samr(data, resp.type = "Two class unpaired", nperms = 100)

names(samr.obj)
```

Compute thresholds for different deltas

```{r}
delta <- 1.9 # define the delta
delta.table <- samr.compute.delta.table(samr.obj, min.foldchange = delta)
```

```{r}
# Look at the whole delta table
datatable(delta.table)
```

Let’s select delta with median FDR <10%.

```{r}
# Check delta related to median FDR of 0.1
delta.table[delta.table[, "median FDR"] < 0.1,][1,]
```

```{r}
samr.plot(samr.obj, delta)  # Check SAM plot
```

## B) Comente sobre la cantidad de genes significativos.

### Get significant genes

```{r}
# Summarize
siggenes.table <- samr.compute.siggenes.table(samr.obj,
                                              delta,
                                              data,
                                              delta.table,
                                              min.foldchange = delta)

datatable(siggenes.table$genes.lo)  # Check how table with the results look like
datatable(siggenes.table$genes.up)  # Check how table with the results look like
```

```{r}
# Enable Warning messages
options(warn = 0)
```