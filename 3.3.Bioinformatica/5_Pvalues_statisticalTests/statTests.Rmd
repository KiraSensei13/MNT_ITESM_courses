---
title: "Statistical Tests"
author: "Antonio Osamu Katagiri Tanaka - A01212611@itesm.mx"
date: March 27, 2020
output:
  pdf_document: default
  html_notebook: default
classoption: a4paper
geometry: margin=1.75cm
---

```{r}
# Clear all objects (from the workspace)
rm(list = ls())

# Suppress Warning messages
options(warn = -1)

# Turn off scientific notation like 1e+06
# options(scipen=999)

# Load Libs
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
library(siggenes)
source("./statistical_tests_lib.R")
```

---

---

# 1) Obtener p-values con un t-test, Wilcoxon y Kolmogorov para:

## A) 2 vectores de datos con distribución normal (rnorm) y diferente media, para número de muestras n= 2……20. Graficar los resultados y comparar.

```{r}
getPvalues <- function(dist) {
    ns = 2:200
    ttest_pval = c()
    wtest_pval = c()
    ktest_pval = c()
    
    for (n in ns) {
        if (dist == "rnorm") {
            vectorA = rnorm(n=n, mean=1, sd=1)
            vectorB = rnorm(n=n, mean=2, sd=1)
        } else {
            vectorA = runif(n, -1, 1)
            vectorB = runif(n, -1, 1)
        }
        
        if (n == max(ns)) {
            plot.densities(vectorA, vectorB, main=paste0("n = ", n))
        }
    
        ttest = t.test(vectorA, vectorB)
        ttest_pval = c(ttest_pval, ttest$p.value)
        #print(ttest$p.value)
    
        wtest = wilcox.test(vectorA, vectorB)
        wtest_pval = c(wtest_pval, wtest$p.value)
        #print(wtest$p.value)
    
        ktest = ks.test(vectorA, vectorB)
        ktest_pval = c(ktest_pval, ktest$p.value)
        #print(ktest$p.value)
    }
    
    if (dist == "rnorm") {
        plot(
            ns, ttest_pval,
            main="rnorm",
            xlab="n",
            ylab="p.value",
            type="l",
            col="blue",
            log="x"
        )
    } else {
        plot(
            ns, ttest_pval,
            main="runif",
            xlab="n",
            ylab="p.value",
            type="l",
            col="blue"
        )
    }
    
    lines(
        ns, wtest_pval,
        col="red"
    )
    
    lines(
        ns, ktest_pval,
        col="green"
    )
    
    legend(
        "topright",
        c("t.test","wilcox.test","ks.test"),
        fill=c("blue","red","green")
    )
}

getPvalues("rnorm")
```

## B) Repetir (A) con 2 vectores de datos generados con la función runif.

```{r}
getPvalues("runif")
```

---

---

# 2) Obtener p-values con un t-test, Wilcoxon, Kolmogorov y SAM para una base de datos GEO de su elección.

---

### Dataset details

**Title:**	Severe acute respiratory syndrome expression profile

**Summary:**	Expression profiling of peripheral blood mononuclear cells (PBMC) from 10 adult patients with severe acute respiratory syndrome (SARS). Results provide insight into the host immune response to the SARS coronavirus.

**Organism:**	Homo sapiens

**Platform:	GPL201:** [HG-Focus] Affymetrix Human HG-Focus Target Array

**Citation:**	
Reghunathan R, Jayapal M, Hsu LY, Chng HH et al. *Expression profile of immune response genes in patients with Severe Acute Respiratory Syndrome.* BMC Immunol 2005 Jan 18;6:2. PMID: [15655079](https://www.ncbi.nlm.nih.gov/pubmed/15655079)

**Reference Series:**	GSE1739

**Sample count:**	14

**Value type:**	count

**Series published:**	2005/01/18

**Dataset taken from:** [GDSbrowser](https://www.ncbi.nlm.nih.gov/sites/GDSbrowser), [GSE1739 query](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE1739), and [GSE1739 geo2r](https://www.ncbi.nlm.nih.gov/geo/geo2r/?acc=GSE1739)

---

The GSE1739 was selected for the Bioinformatics class assignments and activities. The reason behind this decision is the similarities that SARS shares with the novel coronavirus COVID-19. The purpose id to work with up-to-date data that is relecant to the current crisis.

---

### Let's download .soft.gz from GEO and take a look to the data

```{r}
# If you have network access, the more typical way to do this
# would be to use this:
gse <- getGEO("GSE1739",GSEMatrix=FALSE)
# gse <- getGEO(filename=system.file("extdata/GSE781_family.soft.gz",package="GEOquery"))

# Look at gse metadata:
head(Meta(gse))
```

```{r}
# names of all the GSM objects contained in the GSE
names(GSMList(gse))
```

```{r}
# and get the first GSM object on the list
GSMList(gse)[[1]]
```

```{r}
# and the names of the GPLs represented
names(GPLList(gse))
```

### Let's prepare the data for further analysis

```{r}
# First, we need to make sure that all of the GSMs are from the same platform:
gsmplatforms <- lapply(GSMList(gse),function(x) {Meta(x)$platform_id})
head(gsmplatforms)
```

```{r}
# If there are more GPLs, we can filter the original GSMList to include only those GSMs within
# a specific platform and use this list for further processing
gsmlist = Filter(function(gsm) {Meta(gsm)$platform_id=='GPL201'},GSMList(gse))
length(gsmlist)
```

```{r}
# So, now we would like to know what column represents the data that we would like to extract.
# Looking at the first few rows of the Table of a single GSM will likely give us an idea (and
# by the way, GEO uses a convention that the column that contains the single measurement for
# each array is called the VALUE column, which we could use if we don’t know what other column
# is most relevant).

Table(gsmlist[[1]])[1:5,]
```

```{r}
# and get the column descriptions
Columns(gsmlist[[1]])#[1:5,]
```

```{r}
# go through the necessary steps to make a compliant ExpressionSet
# rownames(data.matrix) <- probesets
# colnames(data.matrix) <- names(gsmlist)
# pdata <- data.frame(samples=names(gsmlist))
# rownames(pdata) <- names(gsmlist)
# pheno <- as(pdata,"AnnotatedDataFrame")
# eset2 <- new('ExpressionSet',exprs=data.matrix,phenoData=pheno)
# eset2
gset = getGEO("GSE1739",GSEMatrix=TRUE,destdir="./NCBI_GEO")
gset
```

```{r}
#We will indeed use the VALUE column. We then want to make a matrix of these values like so:

# get the probeset ordering
probesets <- Table(GPLList(gse)[[1]])$ID
# make the data matrix from the VALUE columns from each GSM
# being careful to match the order of the probesets in the platform
# with those in the GSMs
data.matrix <- do.call('cbind',lapply(gsmlist,function(x) 
                                      {tab <- Table(x)
                                       mymatch <- match(probesets,tab$ID_REF)
                                       return(tab$VALUE[mymatch])
                                     }))
data.matrix <- apply(data.matrix,2,function(x) {as.numeric(as.character(x))})
data.matrix <- log2(data.matrix)
data.matrix[1:5,]
```

```{r}
# #Correr SAM
# data.matrix_sam <- sam(
#     data.matrix,
#     c(rep(1,dim(data.matrix)[2])),
#     method = "d.stat",
#     gene.names = colnames(data.matrix)
# )
# sam_pval = data.matrix_sam@p.value
# length(sam_pval)
# 
# #Mostrar resultados de SAM con cierto valor de delta
# data.matrix_sam_sum <- summary(data.matrix_sam, 1.9)
# 
# #Acceder a matrix de Genes significativos
# dim(data.matrix_sam_sum@mat.sig)
```

```{r}
plot.densities(data.matrix, main="BEFORE quantile.normalization()")
```

There is small-to-large variability within groups and small variability across groups, so, let's use quantile normalization

```{r}
data.matrix_qn <- quantile.normalization(data.matrix)
plot.densities(data.matrix_qn, main="AFTER quantile.normalization()")
```

### Compute the p-values for t-test, Wilcoxon, Kolmogorov & SAM

```{r}
pval = de.test(
    x=data.matrix,
    classes=c(rep(1,5),rep(0,5)),
    test=c("ttest", "kolmogorov", "wilcoxon")
)
data.matrix_sam <- sam(
    data.matrix,
    c(rep(1,dim(data.matrix)[2])),
    method = "d.stat",
    gene.names = colnames(data.matrix)
)

sam_pval   = data.matrix_sam@p.value
ttest_pval = pval$ttest
wtest_pval = pval$kolmogorov
ktest_pval = pval$wilcoxon

ns = 1:length(sam_pval)
plot(
    ns, sam_pval,
    main="runif",
    xlab="",
    ylab="p.value",
    log="y",
    col="blue",
    type="p"
)

lines(
    ns, ttest_pval,
    col="red",
    type="p"
)

lines(
    ns, wtest_pval,
    col="green",
    type="p"
)

lines(
    ns, ktest_pval,
    col="magenta",
    type="p"
)

legend(
    "topright",
    c("sam","t.test","wilcox.test","ks.test"),
    fill=c("blue","red","green","magenta")
)

# pval_qn = de.test(
#     x=data.matrix_qn,
#     classes=c(rep(1,5),rep(0,5)),
#     test=c("ttest", "kolmogorov", "wilcoxon")
# )
# data.matrix_qn_sam <- sam(
#     data.matrix_qn,
#     c(rep(1,dim(data.matrix_qn)[2])),
#     method = "d.stat",
#     gene.names = colnames(data.matrix_qn)
# )
# 
# sam_pval_qn   = data.matrix_qn_sam@p.value
# ttest_pval_qn = pval_qn$ttest
# wtest_pval_qn = pval_qn$kolmogorov
# ktest_pval_qn = pval_qn$wilcoxon
```


## A) Verifique si necesita normalizar los datos con quantile normalization. Obtenga p-values antes y después de normalizar.

```{r}
plot(cars)
```

## B) Compare los p-values y grafique. Comente sobre la correlación entre las distintas pruebas estadísticas y la cantidad de genes significativos.

```{r}
plot(cars)
```

## C) Usando el GPL de los datos de GEO, dar una significancia biológica de los genes significativos.

```{r}

```

# 3) Repetir el ejercicio (2) pero con una base de datos de GEO con menos o más muestras, según sea el caso.

```{r}

```

```{r}
# Enable Warning messages
options(warn = 0)
```