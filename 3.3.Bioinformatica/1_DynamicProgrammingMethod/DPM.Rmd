---
title: "Sequence Alignment - Dynamic Programming Method"
output: html_notebook
---

### [Antonio Osamu Katagiri Tanaka](https://www.katagiri-mx.com/about-me) - MNT16 - A01212611

```{r}
# Clear all objects (from the workspace)
rm(list = ls())
```

$$
f(\text{seqX},\text{seqY})=
\begin{array}{cc}
 \Bigg\{ & 
\begin{array}{cc}
 \text{score_match} & \text{if } \text{seqX}=\text{seqY} \\
 \text{score_mismatch} & \text{if } \text{seqX}\neq \text{seqY} \\
\end{array}
 \\
\end{array}
$$

```{r}
f <- function(seqX, seqY, score_match, score_mismatch)
{
  if (seqX == seqY)
  {
    score <- score_match
  }
  else
  {
    score <- score_mismatch
  }
  return(score)
}
```

$$
f_0 = s_{i-1, j-1} + f(\text{seqX},\text{seqY})
$$

```{r}
# Score function
f0 <- function(seqX, seqY, score_match, score_mismatch, score_global_prev)
{
  score_global_curr = score_global_prev + f(seqX, seqY, score_match, score_mismatch)
  return(score_global_curr)
}
```

$$
f_{1_x} = \underset{x \geq 1}{\max } \left\{ s_{i-1,j} - w_x \right\} \text{ & } f_{1_y} = \underset{y \geq 1}{\max } \left\{ s_{i,j-1} - w_y \right\}
$$


```{r}
# Score function if seqX (or seqY) is aligned
f1 <- function(score_global_prev, weight)
{
  score_global_curr <- score_global_prev + weight
  return(score_global_curr)
}
```

$$
f_{score} = \max
\begin{array}{cc}
 \Bigg\{ & 
\begin{array}{cc}
 f_0 \\
 f_{1_x} \\
 f_{1_y} \\
\end{array}
 \\
\end{array}
$$

```{r}
f_score <- function(seqX, seqY, score_match, score_mismatch, score_global_prev, score_global_prevX, score_global_prevY, weight)
{
  score0 = f0(seqX, seqY, score_match, score_mismatch, score_global_prev)
  score1 = f1(score_global_prevX, weight)
  score2 = f1(score_global_prevY, weight)
  score = max(c(score0, score1, score2))
  return(score)
}
```

### Let's write a function f_global_score to calculate the global score using the DPM algorithm
```{r}
f_global_score <- function(Y, X, score_match, score_mismatch, weights, printTable)
{
  # Convert the strings into sequences (arrays) to access each letter in a loop
  # Also, contatenate an empty character at the begining of each sequence
  seq.x <- c('',unlist(strsplit(X, '')))
  seq.y <- c('',unlist(strsplit(Y, '')))
  
  # Initialize the DPM matrix
  tbl_score <- matrix(NA, length(seq.x), length(seq.y))
  
  # Add wy weights
  tbl_score[,1] <- sapply(1:length(seq.x)-1, function(x) weights)
  # Add wx weights
  tbl_score[1,] <- sapply(1:length(seq.y)-1, function(x) weights)
  # Make the top left corner eq to zero
  tbl_score[1,1] <- 0
  
  # Iterate tbl_score and do the DPM algorithm
  # NOTE: start looping from the 3rd element of the sequence as 1st is the "letter" and 2nd is the weight
  for (i in 2:length(seq.x))
  { 
    for (j in 2:length(seq.y))
    {
      tbl_score[i,j] = f_score(
        seq.x[i],            # seqX
        seq.y[j],            # seqY
        score_match,         # score_match
        score_mismatch,      # score_mismatch
        tbl_score[i-1, j-1], # score_global_prev
        tbl_score[i-1,j],    # score_global_prevX
        tbl_score[i,j-1],    # score_global_prevY
        weights)             # weight
    }
  }
  # Save table
  dimnames(tbl_score) = list(
      c('Gap', seq.x[-1]), # row names
      c('Gap', seq.y[-1])) # column names
  # Save global score
  globalScore = tbl_score[nrow(tbl_score),ncol(tbl_score)]
  
  # Print tbl_score and Global Score
  if (printTable)
  {
    print(tbl_score)
    cat("Global Score = ", globalScore, '\n')
  }
  
  return(globalScore)
}
```

### Let's test the f_global_score function with the class example
```{r}
# Input parameters - aka. the 2 sequence to be aligned
X              <- 'TAGGGAACG'
Y              <- 'ATCTAGCGATC'
score_match    <- 2 # my TEC ID = A01212611 -> 1+1=2 ...
score_mismatch <- 0
weights        <- -1
printTable     <- TRUE

f_global_score(Y, X, score_match, score_mismatch, weights, printTable)
```


```{r}
 X <- 'TTCATA'
 Y <- 'TGCTCGTA'

 seq.x <- unlist(strsplit(X, ''))
 seq.y <- unlist(strsplit(Y, ''))

 seq.x <- c('',seq.x)
 seq.y <- c('',seq.y)

 match <- 5
 mismatch <- -2
 indel <- -6

 ## initial the score matrix
 score <- matrix(NA, length(seq.x), length(seq.y))
 score[,1] <- sapply(1:length(seq.x)-1, function(x) x * indel)
 score[1,] <- sapply(1:length(seq.y)-1, function(x) x * indel)

 ## The dynamic programming, global alignment recursion
 for (i in 2:length(seq.x)) {
     for (j in 2:length(seq.y)){
         # seq.x[i] , seq.y[j] are aligned
         if ( seq.x[i] == seq.y[j]) {
             score[i,j] <- score[i-1, j-1] + match
         } else {
             score[i,j] <- score[i-1, j-1] + mismatch
         }
         # seq.x[i] aligned to -
         sc <- score[i-1,j] + indel
         if (sc > score[i,j])
             score[i,j] = sc
         # seq.y[j] aligned to -
         sc <- score[i,j-1] + indel
         if (sc > score[i,j])
             score[i,j] = sc
     }
 }

 ## Traceback
 i <- length(seq.x)
 j <- length(seq.y)
 ax <- character()
 ay <- character()
 while (i > 1 && j >1){
     ## case 1: best was seq.x[i] aligned to seq.y[j]
     sc <- score[i-1,j-1]
     if (seq.x[i] == seq.y[j]) {
         sc <- sc + match
     } else {
         sc <- sc + mismatch
     }
     if (sc == score[i,j]) {
         ax <- c(seq.x[i], ax)
         ay <- c(seq.y[j], ay)
         i <- i -1
         j <- j-1
         next
     }
     ## case 2: best was seq.x[i] aligned to -
     if ((score[i-1,j] + indel) == score[i,j]) {
         ax <- c(seq.x[i], ax)
         ay <- c("-", ay)
         i <- i-1
         next
     }
     ## case 3: best was seq.y[j] aligned to -
     if ((score[i,j-1] + indel) == score[i,j]) {
         ax <- c("-", ax)
         ay <- c(seq.y[j], ay)
         j <- j-1
         next
     }
 }

 cat ("Sequence X: ", X,"\n")
 cat ("Sequence Y: ", Y,"\n")
 cat ("Scoring system: ", match, " for match; ", mismatch, " for mismatch; ", indel, " for gap", "\n\n")

 cat ("Dynamic programming matrix:\n")
 print (score)

 cat ("\nAlignment:\n")
 cat (paste(ax, collapse=''), "\n")
 cat (paste(ay, collapse=''),"\n\n")
 cat ("Optimum alignment score: ", score[length(score)],"\n")
```

