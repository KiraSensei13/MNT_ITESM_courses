# bwt2 = function(x, printTables = FALSE, eof = '!') {
#
# }
#
#
# printTables = TRUE
# bwt("banana", printTables)[[1]]
# bwt("appellee", printTables)[[1]]
# bwt("Tomorrow and tomorrow and tomorrow")[[1]]
bwt = function(x, printTables = FALSE, eof = '!') {
# Let's use !, as $ is used in RegEx patterns
if (grepl(eof, "[[:cntrl:]]")) stop("eof can't be a RegEx control character")
# Make sure the input doesnt contain !
if (grepl(eof, x)) stop("x can't contain eof character")
# concatenate the eof char to the input string
x = paste0(x, eof)
# get the number of characters in x
n = nchar(x)
# function to take first character and add to the end
rotate = function(x) {
paste0(substring(x, 2), substring(x, 1, 1))
}
# Create table of all possible rotations
tbl = c(x, vector("character", n - 1))
for(i in 2:n) {
tbl[i] = rotate(tbl[i - 1])
}
# Sort rows alphabetically
tbl = sort(tbl)
# Return last column of the table
out = sapply(tbl, substring, first = n, USE.NAMES = FALSE)
# concatenate all letters
out = paste(out, collapse = '')
# Get SA and Suffixes
noWords      = length(tbl)
tbl_sa       = c()
tbl_suffixes = c()
for (i in 1:noWords)
{
suffix                = strsplit(tbl[i], '!')
tbl_suffixes          = c(tbl_suffixes, paste0(suffix[[1]][1], eof))
tbl_sa                = c(tbl_sa, nchar(suffix[[1]][2]))
tbl_sa[is.na(tbl_sa)] = 0 # replacing NA's with 0's
}
# print tables (FOR DEBUGGING PURPOSES) - This paragraph could (and shall) be removed
if (printTables)
{
tbl_p          = c("BWT:",tbl)
tbl_sa_p       = c("SA:",tbl_sa)
tbl_suffixes_p = c("Suffix:",tbl_suffixes)
for (i in 1:length(tbl_p))
{
print(c(tbl_p[i],tbl_sa_p[i],tbl_suffixes_p[i]))
}
}
# return BWT
out_lst = list(out) # bwt, suffixArray
return(out_lst)
}
printTables = TRUE
bwt("banana", printTables)[[1]]
printTables = TRUE
bwt("appellee", printTables)[[1]]
ibwt = function(x, printTables = FALSE, eof = '!') {
if (!grepl(eof, x)) stop("x doesn't contain eof character")
tbl = x = strsplit(x, '')[[1]]
while (nchar(tbl[1]) < length(x)) {
sorted = sort(tbl)
tbl    = apply(cbind(x, sorted), 1, paste, collapse = '')
}
# print tables (FOR DEBUGGING PURPOSES) - This paragraph could (and shall) be removed
if (printTables)
{
noWords = length(tbl)
for (i in 1:noWords){ print(tbl[i]) }
}
# Choose the word that ends with the eof character
out = sub(eof, '', tbl[grepl(paste0(eof, '$'), tbl)])
# return iBWT
out_lst = list(out)
return(out_lst)
}
printTables = TRUE
ibwt("annb!aa",   printTables)
ibwt("e!elplepa", printTables)
printTables = TRUE
ibwt(bwt("Tomorrow and tomorrow and tomorrow")[[1]])
rankbwt = function(x, eof = '!') {
if (!grepl(eof, x)) stop("x doesn't contain eof character")
bwt_char = strsplit(x, '')[[1]]
tots  = list()
ranks = c()
for (c in bwt_char) {
charExists = (c %in% names(tots))
if (!charExists) {
tots[[c]] = 0
}
ranks = c(ranks, tots[[c]])
tots[[c]] = tots[[c]] + 1
}
ranks = paste(ranks, collapse='')
tots  = tots[order(names(tots),decreasing=FALSE)]
# return iBWT
out_lst = list(ranks, tots)
return(out_lst)
}
firstCol = function(tots) {
range  = list()
first  = c()
pointer = 0
for (ele in names(tots)) {
char  = names(tots[ele])
count = tots[[ele]]
range[[char]] = c(pointer, pointer+count)
pointer = pointer+count
for (c in 1:count) {
first = c(first, char)
}
}
first = paste(sort(first), collapse='')
# return iBWT
out_lst = list(first, range)
return(out_lst)
}
T_str = "Tomorrow_and_tomorrow_and_tomorrow" #"abaaba"
printTables = FALSE
L_str = bwt(T_str, printTables)[[1]]
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[1]]
print(T_str)
print(L_str)
print(rank)
print(F_str)
countMatches = function(L_str, p_str) {
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[2]]
z = nchar(rank)
print(z)
print(rank)
# Extract last (one) character
n_last = 1
p_str_lst = substr(p_str, nchar(p_str) - n_last + 1, nchar(p_str))
l = F_str[[p_str_lst]][1]
r = F_str[[p_str_lst]][2]
i = nchar(p_str)-1
while (i > 0 & r > l) {
# Get ith character of p_str
c = substring(p_str, i, i)
# scan from left, looking for occurrences of c
j = l
print(">>>")
print(j)
print(as.numeric(substring(rank, j, j)))
while (j < r) {
if (substring(L_str, j, j) == c) {
l = F_str[[c]][1] + as.numeric(substring(rank, j, j))
break
}
j = j + 1
}
if (j == r) {
l = r
# no occurrences -> no match
break
}
r = r - 1
while (substring(L_str, r, r) != c) {
r = r - 1
}
r = F_str[[c]][1] + as.numeric(substring(rank, j, j)) + 1
i = i - 1
}
return(r - l)
}
T_str = "Tomorrow_and_tomorrow_and_tomorrow"
L_str = bwt(T_str, printTables)[[1]]
countMatches(L_str, "omorrow")
T_str = "banana" #"abaaba"
printTables = FALSE
L_str = bwt(T_str, printTables)[[1]]
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[1]]
print(T_str)
print(L_str)
print(rank)
print(F_str)
countMatches = function(L_str, p_str) {
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[2]]
z = nchar(rank)
print(z)
print(rank)
# Extract last (one) character
n_last = 1
p_str_lst = substr(p_str, nchar(p_str) - n_last + 1, nchar(p_str))
l = F_str[[p_str_lst]][1]
r = F_str[[p_str_lst]][2]
i = nchar(p_str)-1
while (i > 0 & r > l) {
# Get ith character of p_str
c = substring(p_str, i, i)
# scan from left, looking for occurrences of c
j = l
print(">>>")
print(j)
print(as.numeric(substring(rank, j, j)))
while (j < r) {
if (substring(L_str, j, j) == c) {
l = F_str[[c]][1] + as.numeric(substring(rank, j, j))
break
}
j = j + 1
}
if (j == r) {
l = r
# no occurrences -> no match
break
}
r = r - 1
while (substring(L_str, r, r) != c) {
r = r - 1
}
r = F_str[[c]][1] + as.numeric(substring(rank, j, j)) + 1
i = i - 1
}
return(r - l)
}
T_str = "Tomorrow_and_tomorrow_and_tomorrow"
L_str = bwt(T_str, printTables)[[1]]
countMatches(L_str, "ana")
countMatches = function(L_str, p_str) {
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[2]]
z = nchar(rank)
print(z)
print(rank)
# Extract last (one) character
n_last = 1
p_str_lst = substr(p_str, nchar(p_str) - n_last + 1, nchar(p_str))
l = F_str[[p_str_lst]][1]
r = F_str[[p_str_lst]][2]
i = nchar(p_str)-1
while (i > 0 & r > l) {
# Get ith character of p_str
c = substring(p_str, i, i)
# scan from left, looking for occurrences of c
j = l
print(">>>")
print(j)
print(as.numeric(substring(rank, j, j)))
while (j < r) {
if (substring(L_str, j, j) == c) {
l = F_str[[c]][1] + as.numeric(substring(rank, j, j))
break
}
j = j + 1
}
if (j == r) {
l = r
# no occurrences -> no match
break
}
r = r - 1
while (substring(L_str, r, r) != c) {
r = r - 1
}
r = F_str[[c]][1] + as.numeric(substring(rank, j, j)) + 1
i = i - 1
}
return(r - l)
}
T_str = "banana"
L_str = bwt(T_str, printTables)[[1]]
countMatches(L_str, "ana")
# Clear all objects (from the workspace)
rm(list = ls())
# Import libs
import pandas as pd
# Clear all objects (from the workspace)
rm(list = ls())
# Clear all objects (from the workspace)
rm(list = ls())
print(py$my_df2)
print(my_df2)
print(py$my_df2)
print(py.my_df2)
# Clear all objects (from the workspace)
rm(list = ls())
print(py.my_df2)
make_cnt('banana', printTbl=True)
install.packages("Biobase")
getAndParseGSEMatrices=function (GEO, destdir, AnnotGPL, getGPL = TRUE)
{
GEO <- toupper(GEO)
stub = gsub("\\d{1,3}$", "nnn", GEO, perl = TRUE)
gdsurl <- "https://ftp.ncbi.nlm.nih.gov/geo/series/%s/%s/matrix/";
b = getDirListing(sprintf(gdsurl, stub, GEO))
b=b[-1]
message(sprintf("Found %d file(s)", length(b)))
ret <- list()
for (i in 1:length(b)) {
message(b[i])
destfile = file.path(destdir, b[i])
if (file.exists(destfile)) {
message(sprintf("Using locally cached version: %s", destfile))
}
else {
download.file(sprintf("https://ftp.ncbi.nlm.nih.gov/geo/series/%s/%s/matrix/%s",
stub, GEO, b[i]), destfile = destfile, mode = "wb",
method = getOption("download.file.method.GEOquery"))
}
ret[[b[i]]] <- parseGSEMatrix(destfile, destdir = destdir,
AnnotGPL = AnnotGPL, getGPL = getGPL)$eset
}
return(ret)
}
environment(getAndParseGSEMatrices)<-asNamespace("GEOquery")
assignInNamespace("getAndParseGSEMatrices", getAndParseGSEMatrices, ns="GEOquery")
install.packages("GEOquery")
# Install Packages
library(devtools)
install_github('GEOquery','seandavi')
# Install Packages
install.packages("remotes")
install_github("seandavi/GEOquery")
install.packages("remotes")
install_github("seandavi/GEOquery")
# Install Packages
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install("GEOquery")
# Install GEOquery Bioconductor as it's not available in CRAN
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
#BiocManager::install("GEOquery")
BiocManager::install("Biobase")
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
print(s)
s = "Hello World"
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
print(s)
s = "Hello World"
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
print(s)
install.packages("htmltools")
install.packages("stringi")
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
6.1 Load the Bioconductor libraries:
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
# Install packages from Bioconductor as they're not available in CRAN
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
BiocManager::install("affy")
# Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
# BiocManager::install("affy")
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
install.packages("glue")
install.packages("xml2")
# Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
# BiocManager::install("affy")
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
getGEO(GEO = NULL, filename = NULL, destdir = tempdir(), GSElimits=NULL, GSEMatrix=TRUE,AnnotGPL=FALSE,getGPL=TRUE)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
# BiocManager::install("affy")
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
getGEO(GEO = NULL, filename = NULL, destdir = tempdir(), GSElimits=NULL, GSEMatrix=TRUE,AnnotGPL=FALSE,getGPL=TRUE)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
# BiocManager::install("affy")
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
# Enable Warning messages
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
# BiocManager::install("affy")
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
# Enable Warning messages
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
# BiocManager::install("affy")
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
# Enable Warning messages
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# # Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
# BiocManager::install("affy")
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
# Enable Warning messages
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Install packages from Bioconductor as they're not available in CRAN
# if (!requireNamespace("BiocManager", quietly=TRUE))
#     install.packages("BiocManager")
# BiocManager::install("GEOquery")
# BiocManager::install("Biobase")
# BiocManager::install("affy")
library(GEOquery)
library(Biobase)
library(limma)
library(affy)
# Enable Warning messages
options(warn = 0)
