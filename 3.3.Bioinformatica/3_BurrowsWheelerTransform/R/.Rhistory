ax <- c("-",     ax)
ay <- c(seqy[j], ay)
j <- j-1
}
else #if ((score[i-1,j] + weights) == score[i,j]) # best score is to the left
{
ax <- c(seqx[i], ax)
ay <- c("-",     ay)
i <- i-1
}
# TODO: consider more paths if the best score appears in more than one 'cell'
}
# Add a 'bar' if both are equal
seq.x <- c('',unlist(strsplit(paste(ax, collapse=''), '')))
seq.y <- c('',unlist(strsplit(paste(ay, collapse=''), '')))
bar = character()
for (i in 2:length(seq.x))
{
if (seq.x[i]==seq.y[i])
{
bar <- c(bar, '|')
}
else
{
bar <- c(bar, ' ')
}
}
cat(paste(ax, collapse=''), "\n")
cat(paste(bar, collapse=''), "\n")
cat(paste(ay, collapse=''), "\n")
return (c(ax, ay))
}
f_global_score <- function(Y, X, score_match, score_mismatch, weights, printTable, printAlignment)
{
# Convert the strings into sequences (arrays) to access each letter in a loop
# Also, contatenate an empty character at the begining of each sequence
seq.x <- c('',unlist(strsplit(X, '')))
seq.y <- c('',unlist(strsplit(Y, '')))
# Initialize the DPM matrix
tbl_score <- matrix(NA, length(seq.x), length(seq.y))
# Add wy weights
tbl_score[,1] <- sapply(1:length(seq.x)-1, function(x) weights)
# Add wx weights
tbl_score[1,] <- sapply(1:length(seq.y)-1, function(x) weights)
# Make the top left corner eq to zero
tbl_score[1,1] <- 0
# Iterate tbl_score and do the DPM algorithm
# NOTE: start looping from the 3rd element of the sequence as 1st is the "letter" and 2nd is the weight
for (i in 2:length(seq.x))
{
for (j in 2:length(seq.y))
{
tbl_score[i,j] = f_score(
seq.x[i],            # seqX
seq.y[j],            # seqY
score_match,         # score_match
score_mismatch,      # score_mismatch
tbl_score[i-1, j-1], # score_global_prev
tbl_score[i-1,j],    # score_global_prevX
tbl_score[i,j-1],    # score_global_prevY
weights)             # weight
}
}
# Save table
dimnames(tbl_score) = list(
c('Gap', seq.x[-1]), # row names
c('Gap', seq.y[-1])) # column names
# Save global score
globalScore = tbl_score[nrow(tbl_score),ncol(tbl_score)]
# Print tbl_score and Global Score
if (printTable)
{
print(tbl_score)
cat("Global Score =", globalScore, '\n')
}
if (printAlignment)
{
f_alignment(seq.x, seq.y, tbl_score, score_match, score_mismatch, weights)
}
return(globalScore)
}
# Input parameters - aka. the 2 sequence to be aligned
Y              <- 'TAGGGAACG'
X              <- 'ATCTAGCGATCGATT'
score_match    <- 2 # my TEC ID = A01212611 -> 1+1=2 ...
score_mismatch <- 0
weights        <- -1
printTable     <- TRUE
printAlignment <- TRUE
f_global_score(X, Y, score_match, score_mismatch, weights, printTable, printAlignment)
# Input parameters - aka. the 2 sequence to be aligned
Y              <- 'TATCTGAATTACTTACACCACTGGGCATTGATTTAGATGAGTGGAGTATGGCTACATAC' #NC_045512 COVID-19
X              <- 'TTTCTGATCTCCTTACCAACATGGGTATTGATCTTGATGAGTGGAGTGTAGCTACATTC'    #NC_004718 SARS
score_match    <- 2 # my TEC ID = A01212611 -> 1+1=2 ...
score_mismatch <- 0
weights        <- -1
printTable     <- FALSE
printAlignment <- TRUE
sc_best = f_global_score(X, Y, score_match, score_mismatch, weights, printTable, printAlignment)
cat("Global Score =", sc_best, '\n')
printAlignment <- FALSE
shuffled_scores = c(sc_best)
for (i in 0:10000)
{
X_shuff = stringi::stri_rand_shuffle(X)
Y_shuff = stringi::stri_rand_shuffle(Y)
shuffled_scores = c(
shuffled_scores,
f_global_score(X_shuff, Y_shuff, score_match, score_mismatch, weights, printTable, printAlignment))
}
hist(shuffled_scores,
prob=TRUE, col="black", border="white", xlab="scores", breaks=25)
box(bty="l")
# Draw density function (assuming normal dist)
score_mean = mean(shuffled_scores)
score_sd   = sd(shuffled_scores)
curve(dnorm(x,mean=score_mean,sd=score_sd), add=TRUE, col="red", lwd=2)
text(score_mean, -0.002, round(score_mean,2), cex = 0.7)
text(sc_best, -0.002, round(sc_best,2), cex = 0.7)
t.test(shuffled_scores)
# Clear all objects (from the workspace)
rm(list = ls())
bwt2 = function(x, printTables = FALSE, eof = '!') {
}
printTables = TRUE
bwt("banana", printTables)[[1]]
# Clear all objects (from the workspace)
rm(list = ls())
# bwt2 = function(x, printTables = FALSE, eof = '!') {
#
# }
#
#
# printTables = TRUE
# bwt("banana", printTables)[[1]]
# bwt("appellee", printTables)[[1]]
# bwt("Tomorrow and tomorrow and tomorrow")[[1]]
bwt = function(x, printTables = FALSE, eof = '!') {
# Let's use !, as $ is used in RegEx patterns
if (grepl(eof, "[[:cntrl:]]")) stop("eof can't be a RegEx control character")
# Make sure the input doesnt contain !
if (grepl(eof, x)) stop("x can't contain eof character")
# concatenate the eof char to the input string
x = paste0(x, eof)
# get the number of characters in x
n = nchar(x)
# function to take first character and add to the end
rotate = function(x) {
paste0(substring(x, 2), substring(x, 1, 1))
}
# Create table of all possible rotations
tbl = c(x, vector("character", n - 1))
for(i in 2:n) {
tbl[i] = rotate(tbl[i - 1])
}
# Sort rows alphabetically
tbl = sort(tbl)
# Return last column of the table
out = sapply(tbl, substring, first = n, USE.NAMES = FALSE)
# concatenate all letters
out = paste(out, collapse = '')
# Get SA and Suffixes
noWords      = length(tbl)
tbl_sa       = c()
tbl_suffixes = c()
for (i in 1:noWords)
{
suffix                = strsplit(tbl[i], '!')
tbl_suffixes          = c(tbl_suffixes, paste0(suffix[[1]][1], eof))
tbl_sa                = c(tbl_sa, nchar(suffix[[1]][2]))
tbl_sa[is.na(tbl_sa)] = 0 # replacing NA's with 0's
}
# print tables (FOR DEBUGGING PURPOSES) - This paragraph could (and shall) be removed
if (printTables)
{
tbl_p          = c("BWT:",tbl)
tbl_sa_p       = c("SA:",tbl_sa)
tbl_suffixes_p = c("Suffix:",tbl_suffixes)
for (i in 1:length(tbl_p))
{
print(c(tbl_p[i],tbl_sa_p[i],tbl_suffixes_p[i]))
}
}
# return BWT
out_lst = list(out) # bwt, suffixArray
return(out_lst)
}
printTables = TRUE
bwt("banana", printTables)[[1]]
printTables = TRUE
bwt("appellee", printTables)[[1]]
ibwt = function(x, printTables = FALSE, eof = '!') {
if (!grepl(eof, x)) stop("x doesn't contain eof character")
tbl = x = strsplit(x, '')[[1]]
while (nchar(tbl[1]) < length(x)) {
sorted = sort(tbl)
tbl    = apply(cbind(x, sorted), 1, paste, collapse = '')
}
# print tables (FOR DEBUGGING PURPOSES) - This paragraph could (and shall) be removed
if (printTables)
{
noWords = length(tbl)
for (i in 1:noWords){ print(tbl[i]) }
}
# Choose the word that ends with the eof character
out = sub(eof, '', tbl[grepl(paste0(eof, '$'), tbl)])
# return iBWT
out_lst = list(out)
return(out_lst)
}
printTables = TRUE
ibwt("annb!aa",   printTables)
ibwt("e!elplepa", printTables)
printTables = TRUE
ibwt(bwt("Tomorrow and tomorrow and tomorrow")[[1]])
rankbwt = function(x, eof = '!') {
if (!grepl(eof, x)) stop("x doesn't contain eof character")
bwt_char = strsplit(x, '')[[1]]
tots  = list()
ranks = c()
for (c in bwt_char) {
charExists = (c %in% names(tots))
if (!charExists) {
tots[[c]] = 0
}
ranks = c(ranks, tots[[c]])
tots[[c]] = tots[[c]] + 1
}
ranks = paste(ranks, collapse='')
tots  = tots[order(names(tots),decreasing=FALSE)]
# return iBWT
out_lst = list(ranks, tots)
return(out_lst)
}
firstCol = function(tots) {
range  = list()
first  = c()
pointer = 0
for (ele in names(tots)) {
char  = names(tots[ele])
count = tots[[ele]]
range[[char]] = c(pointer, pointer+count)
pointer = pointer+count
for (c in 1:count) {
first = c(first, char)
}
}
first = paste(sort(first), collapse='')
# return iBWT
out_lst = list(first, range)
return(out_lst)
}
T_str = "Tomorrow_and_tomorrow_and_tomorrow" #"abaaba"
printTables = FALSE
L_str = bwt(T_str, printTables)[[1]]
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[1]]
print(T_str)
print(L_str)
print(rank)
print(F_str)
countMatches = function(L_str, p_str) {
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[2]]
z = nchar(rank)
print(z)
print(rank)
# Extract last (one) character
n_last = 1
p_str_lst = substr(p_str, nchar(p_str) - n_last + 1, nchar(p_str))
l = F_str[[p_str_lst]][1]
r = F_str[[p_str_lst]][2]
i = nchar(p_str)-1
while (i > 0 & r > l) {
# Get ith character of p_str
c = substring(p_str, i, i)
# scan from left, looking for occurrences of c
j = l
print(">>>")
print(j)
print(as.numeric(substring(rank, j, j)))
while (j < r) {
if (substring(L_str, j, j) == c) {
l = F_str[[c]][1] + as.numeric(substring(rank, j, j))
break
}
j = j + 1
}
if (j == r) {
l = r
# no occurrences -> no match
break
}
r = r - 1
while (substring(L_str, r, r) != c) {
r = r - 1
}
r = F_str[[c]][1] + as.numeric(substring(rank, j, j)) + 1
i = i - 1
}
return(r - l)
}
T_str = "Tomorrow_and_tomorrow_and_tomorrow"
L_str = bwt(T_str, printTables)[[1]]
countMatches(L_str, "omorrow")
T_str = "banana" #"abaaba"
printTables = FALSE
L_str = bwt(T_str, printTables)[[1]]
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[1]]
print(T_str)
print(L_str)
print(rank)
print(F_str)
countMatches = function(L_str, p_str) {
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[2]]
z = nchar(rank)
print(z)
print(rank)
# Extract last (one) character
n_last = 1
p_str_lst = substr(p_str, nchar(p_str) - n_last + 1, nchar(p_str))
l = F_str[[p_str_lst]][1]
r = F_str[[p_str_lst]][2]
i = nchar(p_str)-1
while (i > 0 & r > l) {
# Get ith character of p_str
c = substring(p_str, i, i)
# scan from left, looking for occurrences of c
j = l
print(">>>")
print(j)
print(as.numeric(substring(rank, j, j)))
while (j < r) {
if (substring(L_str, j, j) == c) {
l = F_str[[c]][1] + as.numeric(substring(rank, j, j))
break
}
j = j + 1
}
if (j == r) {
l = r
# no occurrences -> no match
break
}
r = r - 1
while (substring(L_str, r, r) != c) {
r = r - 1
}
r = F_str[[c]][1] + as.numeric(substring(rank, j, j)) + 1
i = i - 1
}
return(r - l)
}
T_str = "Tomorrow_and_tomorrow_and_tomorrow"
L_str = bwt(T_str, printTables)[[1]]
countMatches(L_str, "ana")
countMatches = function(L_str, p_str) {
r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[2]]
z = nchar(rank)
print(z)
print(rank)
# Extract last (one) character
n_last = 1
p_str_lst = substr(p_str, nchar(p_str) - n_last + 1, nchar(p_str))
l = F_str[[p_str_lst]][1]
r = F_str[[p_str_lst]][2]
i = nchar(p_str)-1
while (i > 0 & r > l) {
# Get ith character of p_str
c = substring(p_str, i, i)
# scan from left, looking for occurrences of c
j = l
print(">>>")
print(j)
print(as.numeric(substring(rank, j, j)))
while (j < r) {
if (substring(L_str, j, j) == c) {
l = F_str[[c]][1] + as.numeric(substring(rank, j, j))
break
}
j = j + 1
}
if (j == r) {
l = r
# no occurrences -> no match
break
}
r = r - 1
while (substring(L_str, r, r) != c) {
r = r - 1
}
r = F_str[[c]][1] + as.numeric(substring(rank, j, j)) + 1
i = i - 1
}
return(r - l)
}
T_str = "banana"
L_str = bwt(T_str, printTables)[[1]]
countMatches(L_str, "ana")
# Clear all objects (from the workspace)
rm(list = ls())
# Import libs
import pandas as pd
# Clear all objects (from the workspace)
rm(list = ls())
# Clear all objects (from the workspace)
rm(list = ls())
print(py$my_df2)
print(my_df2)
print(py$my_df2)
print(py.my_df2)
# Clear all objects (from the workspace)
rm(list = ls())
print(py.my_df2)
make_cnt('banana', printTbl=True)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Integrate python to R
library(reticulate)
use_virtualenv("r-reticulate")
py_available(TRUE)
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Integrate python to R
library(reticulate)
use_virtualenv("r-reticulate")
py_available(TRUE)
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Integrate python to R
library(reticulate)
use_virtualenv("r-reticulate")
py_available(TRUE)
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Integrate python to R
library(reticulate)
use_virtualenv("r-reticulate")
py_available(TRUE)
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Integrate python to R
library(reticulate)
use_virtualenv("r-reticulate")
py_available(TRUE)
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Integrate python to R
library(reticulate)
use_virtualenv("r-reticulate")
py_available(TRUE)
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Integrate python to R
library(reticulate)
use_virtualenv("r-reticulate")
py_available(TRUE)
# Enable Warning messages
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Integrate python to R
library(reticulate)
use_virtualenv("r-reticulate")
py_available(TRUE)
# Enable Warning messages
options(warn = 0)
# Clear all objects (from the workspace)
rm(list = ls())
# Suppress Warning messages
options(warn = -1)
# Integrate python to R
library(reticulate)
use_virtualenv("r-reticulate")
py_available(TRUE)
# Enable Warning messages
options(warn = 0)
