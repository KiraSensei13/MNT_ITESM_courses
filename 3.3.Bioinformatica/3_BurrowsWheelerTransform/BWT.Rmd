---
title Sequence Alignment - Dynamic Programming Method
output html_document
---

### [Antonio Osamu Katagiri Tanaka](httpswww.katagiri-mx.comabout-me) - MNT16 - A01212611

#### Burrows, M., & Wheeler, D. J. (1994). A Block-Sorting Lossless Data Compression Algorithm. Digital Equipment Corporation (Vol. 28). Palo Alto, California. Retrieved from httpswww.hpl.hp.comtechreportsCompaq-DECSRC-RR-124.pdf

```{r}
# Clear all objects (from the workspace)
rm(list = ls())
```

# Burrows-Wheeler Transform

```{r}
bwt = function(x, printTables = FALSE, eof = '!') {
  
  # Let's use !, as $ is used in RegEx patterns
  if (grepl(eof, "[[:cntrl:]]")) stop("eof can't be a RegEx control character")
  # Make sure the input doesnt contain !
  if (grepl(eof, x)) stop("x can't contain eof character")
  
  # concatenate the eof char to the input string
  x = paste0(x, eof)
  # get the number of characters in x
  n = nchar(x)
  
  # function to take first character and add to the end
  rotate = function(x) {
    paste0(substring(x, 2), substring(x, 1, 1))
  }
  
  # Create table of all possible rotations
  tbl = c(x, vector("character", n - 1))
  for(i in 2:n) {
    tbl[i] = rotate(tbl[i - 1])
  }
  
  # Sort rows alphabetically
  tbl = sort(tbl)
  
  # Return last column of the table
  out = sapply(tbl, substring, first = n, USE.NAMES = FALSE)
  # concatenate all letters
  out = paste(out, collapse = '')
  
  # Get SA and Suffixes
  noWords      = length(tbl)
  tbl_sa       = c()
  tbl_suffixes = c()
  for (i in 1:noWords)
  { 
    suffix                = strsplit(tbl[i], '!')
    tbl_suffixes          = c(tbl_suffixes, paste0(suffix[[1]][1], eof))
    tbl_sa                = c(tbl_sa, nchar(suffix[[1]][2]))
    tbl_sa[is.na(tbl_sa)] = 0 # replacing NA's with 0's
  }
  
  # print tables (FOR DEBUGGING PURPOSES) - This paragraph could (and shall) be removed
  if (printTables)
  {
    tbl_p          = c("BWT:",tbl)
    tbl_sa_p       = c("SA:",tbl_sa)
    tbl_suffixes_p = c("Suffix:",tbl_suffixes)
    for (i in 1:length(tbl_p))
    {
      print(c(tbl_p[i],tbl_sa_p[i],tbl_suffixes_p[i]))
    }
  }
  
  # return BWT
  out_lst = list(out) # bwt, suffixArray
  return(out_lst)
}
```

A BWT example

```{r}
printTables = TRUE
bwt("banana", printTables)[[1]]
```

Another Example

```{r}
printTables = TRUE
bwt("appellee", printTables)[[1]]
```


# Inverse BWT

```{r}
ibwt = function(x, printTables = FALSE, eof = '!') {
  if (!grepl(eof, x)) stop("x doesn't contain eof character")
  
  tbl = x = strsplit(x, '')[[1]]

  while (nchar(tbl[1]) < length(x)) {
    sorted = sort(tbl)
    tbl    = apply(cbind(x, sorted), 1, paste, collapse = '')
  }
  
  # print tables (FOR DEBUGGING PURPOSES) - This paragraph could (and shall) be removed
  if (printTables)
  {
    noWords = length(tbl)
    for (i in 1:noWords){ print(tbl[i]) }
  }
  
  # Choose the word that ends with the eof character
  out = sub(eof, '', tbl[grepl(paste0(eof, '$'), tbl)])
  
  # return iBWT
  out_lst = list(out)
  return(out_lst)
}
```

Recovering the string

```{r}
printTables = TRUE
ibwt("annb!aa",   printTables)
ibwt("e!elplepa", printTables)
```

Another BWT Example

```{r}
printTables = TRUE
ibwt(bwt("Tomorrow and tomorrow and tomorrow")[[1]])
```

# Searching with BWT LF Mapping

## B-ranking
Given BWT string bw, returns a parallel list of B-ranks. Also returns tots, a mapping from characters to # times the character appears in BWT.

```{r}
rankbwt = function(x, eof = '!') {
  if (!grepl(eof, x)) stop("x doesn't contain eof character")
  bwt_char = strsplit(x, '')[[1]]
  
  tots  = list()
  ranks = c()
  for (c in bwt_char) {
    
    charExists = (c %in% names(tots))
    if (!charExists) {
      tots[[c]] = 0
    }
    
    ranks = c(ranks, tots[[c]])
    tots[[c]] = tots[[c]] + 1
  }
  
  ranks = paste(ranks, collapse='')
  
  # return iBWT
  out_lst = list(ranks, tots)
  return(out_lst)
}
```

Return a map from characters to the range of cells in the first column containing the character.

```{r}
firstCol = function(tots) {
  first = c()
  for (ele in names(tots)) {
    char = names(tots[ele]) 
    count = tots[[ele]]
    
    for (c in 1:count) {
      first = c(first, char)
    }
  }
  
  first = paste(sort(first), collapse='')
  
  # return iBWT
  out_lst = list(first)
  return(out_lst)
}
```

An example:

```{r}
T_str = "abaaba"
printTables = FALSE
L_str = bwt(T_str, printTables)[[1]]

r        = rankbwt(L_str)
rank     = r[[1]]
rankTots = r[[2]]
F_str    = firstCol(rankTots)[[1]]


print(T_str)
print(F_str)
print(L_str)
print(rank)
```

# Searching occurrences
Given BWT(T) and a pattern string p, return the number of times p occurs in T.

```{r}
countMatches = function(L_str, p_str) {
  r        = rankbwt(L_str)
  rank     = r[[1]]
  rankTots = r[[2]]
  F_str    = firstCol(rankTots)[[1]]
  
  print(F_str[p_str[-1]])
  print(length(p_str)-2)
}

T_str = "Tomorrow_and_tomorrow_and_tomorrow"
L_str = bwt(T_str, printTables)[[1]]
countMatches(L_str, "omorrow")
```

```{python}
def rankBwt(bw):
  """ Given BWT string bw, returns a parallel list of B-ranks. Also
    returns tots, a mapping from characters to # times the
    character appears in BWT. """
  tots = dict()
  ranks = []
  for c in bw:
    if c not in tots:
      tots[c] = 0
    ranks.append(tots[c])
    tots[c] += 1
  return ranks, tots
  
def firstCol(tots):
  """ Return a map from characters to the range of cells in the first
    column containing the character. """
  first = {}
  totc = 0
  for c, count in sorted(tots.items()):
    first[c] = (totc, totc + count)
    totc += count
  return first

def countMatches(bw, p):
  """ Given BWT(T) and a pattern string p, return the number of times
    p occurs in T. """
  ranks, tots = rankBwt(bw)
  first = firstCol(tots)
  l, r = first[p[-1]]
  i = len(p)-2
  while i >= 0 and r > l:
    c = p[i]
    # scan from left, looking for occurrences of c
    j = l
    while j < r:
      if bw[j] == c:
        l = first[c][0] + ranks[j]
        break
      j += 1
    if j == r:
      l = r
      break # no occurrences -> no match
    r -= 1
    while bw[r] != c:
      r -= 1
    r = first[c][0] + ranks[r] + 1
    i -= 1
  return r - l
  
res = countMatches("w!wwdd__nnoooaattTmmmrrrrrrooo__ooo", "r")
print(res)
```


https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/

https://www.cs.cmu.edu/~ckingsf/bioinfo-lectures/bwt.pdf

http://www.cs.jhu.edu/~langmea/resources/bwt_fm.pdf
