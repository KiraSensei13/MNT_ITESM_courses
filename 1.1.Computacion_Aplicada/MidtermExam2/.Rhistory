legend(
'topleft',
inset = .05,
legend = c(
"deSolve function 1",
"RK4 function 1",
"deSolve function 2",
"RK4 function 2"
),
col = c('#0d47a1', '#42a5f5', '#b71c1c', '#e53935'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
# ODEs to be evaluated (enter it as a string):
funct_1 = "-16*x + 0.08*x*y"
funct_2 = "4.5*y - 0.9*x*y"
# Enter Y initial Value:
init_y = 4
# Enter X initial Value:
init_x = 4
# Enter Upper bound
upper_bound = 24
# Enter number of steps (the step size is going to be calculated calculated):
number_of_steps = 1000
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,
1,
5.5)
library (deSolve)
RKPlot2 <-
function(func_1,
func_2,
x0,
y0,
x1,
n,
plot_ymin,
plot_ymax) {
# Plot of the second, third and fourth order RK approximations
#
# Parameters
# ----------
# func : string
# ODE function of two variabless
# x0, y0 : numeric
# initial values
# x1 : numeric
# upper bound
# n : numeric
# number of steps
# plot_ymin, plot_ymax : numeric
# set the plot y-axis range
#
# Returns
# -------
# void
# Calculate aproxminations
rk4_1 = rungeKutta4(func_1, x0, y0, x1, n)
rk4_2 = rungeKutta4(func_2, x0, y0, x1, n)
x4_1 <- rk4_1[, 1]
y4_1 <- rk4_1[, 2]
x4_2 <- rk4_2[, 1]
y4_2 <- rk4_2[, 2]
# Compute analytical answer of the ODE approximations
model_1 <- function(x, y, parms) {
with(as.list(c(y, parms)), {
dy = eval(parse(text = funct_1), envir = list(x, y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <-
seq(init_x,
upper_bound,
length(init_x:upper_bound) / number_of_steps)
out_1 <- ode(y, times = x, model_1, parms)
model_2 <- function(x, y, parms) {
with(as.list(c(y, parms)), {
dy = eval(parse(text = funct_2), envir = list(x, y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <-
seq(init_x,
upper_bound,
length(init_x:upper_bound) / number_of_steps)
out_2 <- ode(y, times = x, model_2, parms)
### Plot
# deSolve function 1
plot(
out_1,
xlab = "x",
ylab = "f'(x)",
type = "l",
main = ' Runge-Kutta ',
col = "black",
lwd = 2,
ylim=c(plot_ymin,plot_ymax)
)
# RK4 function 1
lines(x4_1, y4_1, col = "#42a5f5") # blue lighten-1
# deSolve function 2
lines(out_2, col = "#b71c1c", lwd = 2) # blue lighten-1
# RK4 function 2
lines(x4_2, y4_2, col = "#e53935") # red darken-1
legend(
'topleft',
inset = .05,
legend = c(
"deSolve function 1",
"RK4 function 1",
"deSolve function 2",
"RK4 function 2"
),
col = c('#0d47a1', '#42a5f5', '#b71c1c', '#e53935'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
# -----
# dx_1/dt = -(2/25)x_1 + (1/50)x_2
# dx_2/dt =  (2/25)x_1 - (2/25)x_2
# ODEs to be evaluated (enter it as a string):
funct_1 = "-16*x + 0.08*x*y"
funct_2 = "4.5*y - 0.9*x*y"
# Enter Y initial Value:
init_y = 4
# Enter X initial Value:
init_x = 4
# Enter Upper bound
upper_bound = 24
# Enter number of steps (the step size is going to be calculated calculated):
number_of_steps = 1000
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,
1,
5.5)
library (deSolve)
RKPlot2 <-
function(func_1,
func_2,
x0,
y0,
x1,
n,
plot_ymin,
plot_ymax) {
# Plot of the second, third and fourth order RK approximations
#
# Parameters
# ----------
# func : string
# ODE function of two variabless
# x0, y0 : numeric
# initial values
# x1 : numeric
# upper bound
# n : numeric
# number of steps
# plot_ymin, plot_ymax : numeric
# set the plot y-axis range
#
# Returns
# -------
# void
# Calculate aproxminations
rk4_1 = rungeKutta4(func_1, x0, y0, x1, n)
rk4_2 = rungeKutta4(func_2, x0, y0, x1, n)
x4_1 <- rk4_1[, 1]
y4_1 <- rk4_1[, 2]
x4_2 <- rk4_2[, 1]
y4_2 <- rk4_2[, 2]
# Compute analytical answer of the ODE approximations
model_1 <- function(x, y, parms) {
with(as.list(c(y, parms)), {
dy = eval(parse(text = funct_1), envir = list(x, y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <-
seq(init_x,
upper_bound,
length(init_x:upper_bound) / number_of_steps)
out_1 <- ode(y, times = x, model_1, parms)
model_2 <- function(x, y, parms) {
with(as.list(c(y, parms)), {
dy = eval(parse(text = funct_2), envir = list(x, y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <-
seq(init_x,
upper_bound,
length(init_x:upper_bound) / number_of_steps)
out_2 <- ode(y, times = x, model_2, parms)
### Plot
# deSolve function 1
plot(
out_1,
xlab = "x",
ylab = "f'(x)",
type = "l",
main = ' Runge-Kutta ',
col = "black",
lwd = 2,
ylim=c(plot_ymin,plot_ymax)
)
# RK4 function 1
lines(x4_1, y4_1, col = "#42a5f5") # blue lighten-1
# deSolve function 2
lines(out_2, col = "#b71c1c", lwd = 2) # blue lighten-1
# RK4 function 2
lines(x4_2, y4_2, col = "#e53935") # red darken-1
legend(
'topleft',
inset = .05,
legend = c(
"deSolve function 1",
"RK4 function 1",
"deSolve function 2",
"RK4 function 2"
),
col = c('#0d47a1', '#42a5f5', '#b71c1c', '#e53935'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
# ODEs to be evaluated (enter it as a string):
funct_1 = "-16*x + 0.08*x*y"
funct_2 = "4.5*y - 0.9*x*y"
# Enter Y initial Value:
init_y = 4
# Enter X initial Value:
init_x = 4
# Enter Upper bound
upper_bound = 24
# Enter number of steps (the step size is going to be calculated calculated):
number_of_steps = 1000
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,
1,
5.5)
# Runge-Kutta - 4th order
rungeKutta4 <- function(funct, x0, y0, x1, n) {
f <- function(P, N) {
return(eval(parse(text = funct), envir = list(x = P, y = N)))
}
vx <- double(n + 1)
vy <- double(n + 1)
vx[1] <- x <- x0
vy[1] <- y <- y0
h <- (x1 - x0) / n
for (i in 1:n) {
# from http://campus.usal.es/~mpg/Personales/PersonalMAGL/Docencia/MetNumTema4Teo(09-10).pdf
k1 <- h * f(x, y)
k2 <- h * f(x + 0.5 * h, y + 0.5 * k1)
k3 <- h * f(x + 0.5 * h, y + 0.5 * k2)
k4 <- h * f(x + h, y + k3)
vx[i + 1] <- x <- x0 + i * h
vy[i + 1] <- y <- y + (k1 + 2 * k2 + 2 * k3 + k4) / 6
}
return(cbind(vx, vy))
}
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,
1,
5.5)
# ODEs to be evaluated (enter it as a string):
funct_1 = "-0.16*x + 0.08*x*y"
funct_2 = "4.5*y - 0.9*x*y"
# Enter Y initial Value:
init_y = 4
# Enter X initial Value:
init_x = 4
# Enter Upper bound
upper_bound = 24
# Enter number of steps (the step size is going to be calculated calculated):
number_of_steps = 1000
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,
1,
5.5)
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,
-10,
10)
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,
-0,
100)
runge.kutta <- function(funct, initial, x){
f <- function(P, N) {
return(eval(parse(text = funct), envir = list(x = P, y = N)))
}
if(!is.function(f))stop("f must be a function")
if(!is.numeric(initial)||length(initial)!=1)stop("initial must be a scalar")
if(!is.vector(x,mode="numeric"))stop("x must be a numeric vector")
y <- initial
for(i in 1:(length(x)-1)){
stepsize <- x[i+1]-x[i]
f1 <- stepsize*f(y[i],x[i])
f2 <- stepsize*f(y[i]+f1/2,x[i]+stepsize/2)
f3 <- stepsize*f(y[i]+f2/2,x[i]+stepsize/2)
f4 <- stepsize*f(y[i]+f3,x[i]+stepsize)
y <- c(y,y[i]+(f1+2*f2+2*f3+f4)/6)}
y
}
x = seq(4,10,0.1)
y = runge.kutta("-0.16*x + 0.08*x*y",4,x)
plot(x,y)
# ODEs to be evaluated (enter it as a string):
funct_1 = "-0.16*x + 0.08*x*y"
funct_2 = "4.5*y - 0.9*x*y"
# Enter Y initial Value:
init_y = 4
# Enter X initial Value:
init_x = 4
# Enter Upper bound
upper_bound = 10
# Enter number of steps (the step size is going to be calculated calculated):
number_of_steps = 1000
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,
-0,
100)
runge.kutta <- function(funct, initial, x){
f <- function(P, N) {
return(eval(parse(text = funct), envir = list(x = P, y = N)))
}
if(!is.function(f))stop("f must be a function")
if(!is.numeric(initial)||length(initial)!=1)stop("initial must be a scalar")
if(!is.vector(x,mode="numeric"))stop("x must be a numeric vector")
y <- initial
for(i in 1:(length(x)-1)){
stepsize <- x[i+1]-x[i]
f1 <- stepsize*f(y[i],x[i])
f2 <- stepsize*f(y[i]+f1/2,x[i]+stepsize/2)
f3 <- stepsize*f(y[i]+f2/2,x[i]+stepsize/2)
f4 <- stepsize*f(y[i]+f3,x[i]+stepsize)
y <- c(y,y[i]+(f1+2*f2+2*f3+f4)/6)}
y
}
x = seq(4,10,0.1)
y = runge.kutta("-0.16*x + 0.08*x*y",4,x)
y = runge.kutta("4.5*y - 0.9*x*y",4,x)
plot(x,y)
library (deSolve)
RKPlot2 <-
function(func_1,
func_2,
x0,
y0,
x1,
n,
plot_ymin,
plot_ymax) {
# Plot of the second, third and fourth order RK approximations
#
# Parameters
# ----------
# func : string
# ODE function of two variabless
# x0, y0 : numeric
# initial values
# x1 : numeric
# upper bound
# n : numeric
# number of steps
# plot_ymin, plot_ymax : numeric
# set the plot y-axis range
#
# Returns
# -------
# void
# Calculate aproxminations
rk4_1 = rungeKutta4(func_1, x0, y0, x1, n)
rk4_2 = rungeKutta4(func_2, x0, y0, x1, n)
x4_1 <- rk4_1[, 1]
y4_1 <- rk4_1[, 2]
x4_2 <- rk4_2[, 1]
y4_2 <- rk4_2[, 2]
# Compute analytical answer of the ODE approximations
model_1 <- function(x, y, parms) {
with(as.list(c(y, parms)), {
dy = eval(parse(text = funct_1), envir = list(x, y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <-
seq(init_x,
upper_bound,
length(init_x:upper_bound) / number_of_steps)
out_1 <- ode(y, times = x, model_1, parms)
model_2 <- function(x, y, parms) {
with(as.list(c(y, parms)), {
dy = eval(parse(text = funct_2), envir = list(x, y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <-
seq(init_x,
upper_bound,
length(init_x:upper_bound) / number_of_steps)
out_2 <- ode(y, times = x, model_2, parms)
### Plot
# deSolve function 1
plot(
out_1,
xlab = "x",
ylab = "f'(x)",
type = "l",
main = ' Runge-Kutta ',
col = "black",
lwd = 2,
ylim=c(plot_ymin,plot_ymax)
)
# RK4 function 1
lines(x4_1, y4_1, col = "#42a5f5") # blue lighten-1
# deSolve function 2
lines(out_2, col = "#b71c1c", lwd = 2) # blue lighten-1
# RK4 function 2
lines(x4_2, y4_2, col = "#e53935") # red darken-1
legend(
'topleft',
inset = .05,
legend = c(
"deSolve function 1",
"RK4 function 1",
"deSolve function 2",
"RK4 function 2"
),
col = c('#0d47a1', '#42a5f5', '#b71c1c', '#e53935'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
# ODEs to be evaluated (enter it as a string):
funct_1 = "-0.16*x + 0.08*x*y"
funct_2 = "4.5*y - 0.9*x*y"
# Enter Y initial Value:
init_y = 4
# Enter X initial Value:
init_x = 4
# Enter Upper bound
upper_bound = 10
# Enter number of steps (the step size is going to be calculated calculated):
number_of_steps = 1000
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,
-0,
100)
