out <- rungeKutta4_2eq(y0, times, predpreyLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, predpreyLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", xlab = "time", ylab = "population")
# ODEs to be evaluated: P -> x ; N -> y ;
watertanksLV <- function(t, y, p) {
N <- y[1]
P <- y[2]
with(as.list(p), {
dNdt <- c * P - d * N
dPdt <- -a * P + b * N
return(list(c(dNdt, dPdt)))
})
}
# ODEs' coefficients:
a <- (2 / 25)
b <- (1 / 50)
c <- (2 / 25)
d <- (2 / 25)
# ODEs' coefficients/parameters:
p <- c(a = a,
b = b,
c = c,
d = d)
# Initial conditions: P -> x ; N -> y ;
y0 <- c(N = 0, P = 25)
# time vector: to define t0, tf, and the step size
times <- seq(0, 60, 0.1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, watertanksLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", ylab = "gallons")
# time vector: to define t0, tf, and the step size
times <- seq(0, 60, 1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, watertanksLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", ylab = "gallons")
# time vector: to define t0, tf, and the step size
times <- seq(0, 60, 0.1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, watertanksLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", ylab = "gallons")
# time vector: to define t0, tf, and the step size
times <- seq(0, 600, 0.1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, watertanksLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", ylab = "gallons")
# time vector: to define t0, tf, and the step size
times <- seq(0, 600, 1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, watertanksLV, p)
# time vector: to define t0, tf, and the step size
times <- seq(0, 600, 5) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, watertanksLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", ylab = "gallons")
# time vector: to define t0, tf, and the step size
times <- seq(0, 60, 5) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
# time vector: to define t0, tf, and the step size
times <- seq(0, 60, 0.1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, watertanksLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", ylab = "gallons")
# time vector: to define t0, tf, and the step size
times <- seq(0, 600, 1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, watertanksLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", ylab = "gallons")
# time vector: to define t0, tf, and the step size
times <- seq(0, 600, 2) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
# time vector: to define t0, tf, and the step size
times <- seq(0, 600, 5) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
rm(list = ls(all = TRUE)) # Delete workspace
graphics.off() # Clear plots
cat("\014") # Clear console
# Runge-Kutta - 4th order - for a 2-equation 1st order system
rungeKutta4_2eq <- function(y0, times, funct, p) {
# create xx and yy to store the RK calculations for each step
xx <- double(length(times) - 1)
xx[1] <- xn <- y0[1]
yy <- double(length(times) - 1)
yy[1] <- yn <- y0[2]
# get the step size h
h <- (max(times) - min(times)) / length(times)
i = 2 # start populating the 2nd element of xx and yy. the 1st ones are y0
for (tn in times) {
# from https://www.calvin.edu/~scofield/courses/m231/materials/rungeKuttaFormulas.pdf
# and https://math.stackexchange.com/questions/721076/help-with-using-the-runge-kutta-4th-order-method-on-a-system-of-2-first-order-od
# compute the RK constants k and l
kn1 = funct(tn, xn, yn)[[1]][[1]]
ln1 = funct(tn, xn, yn)[[1]][[2]]
kn2 = funct(
tn + h / 2,
xn + (1 / 2) * kn1 * h,
yn + (1 / 2) * ln1 * h)[[1]][[1]]
ln2 = funct(
tn + h / 2,
xn + (1 / 2) * kn1 * h,
yn + (1 / 2) * ln1 * h)[[1]][[2]]
kn3 = funct(
tn + h / 2,
xn + (1 / 2) * kn2 * h,
yn + (1 / 2) * ln2 * h)[[1]][[1]]
ln3 = funct(
tn + h / 2,
xn + (1 / 2) * kn2 * h,
yn + (1 / 2) * ln2 * h)[[1]][[2]]
kn4 = funct(tn + h, xn + kn3 * h, yn + ln3 * h)[[1]][[1]]
ln4 = funct(tn + h, xn + kn3 * h, yn + ln3 * h)[[1]][[2]]
# store the calculated xn and yn within xx and yy respectively
xx[i] = as.numeric(xn)
yy[i] = as.numeric(yn)
# update xn and yn
xn <- xn + h * (kn1 + 2 * kn2 + 2 * kn3 + kn4) / 6
yn <- yn + h * (ln1 + 2 * ln2 + 2 * ln3 + ln4) / 6
# update the index i to avoid overwriting in xx and yy
i = i + 1
}
# remove the last element within xx and yy,
# their length shall match times's length to plot
xx = xx[-length(times + 1)]
yy = yy[-length(times + 1)]
# mmin and mmax are the plot y-limits
mmin = as.numeric(min(xx))
mmax = as.numeric(max(xx))
mmin <- if (mmin > min(yy))
min(yy)
else
mmin
mmax <- if (mmax < max(yy))
max(yy)
else
mmax
# plot xx
plot(
times,
xx,
xlab = "t",
ylab = "f(t)",
type = "l",
main = ' Runge-Kutta ',
col = "#2196f3", # (blue)
lwd = 1,
ylim = c(mmin, mmax)
)
# plot yy in the same image
lines(times, yy, col = "#4caf50") # (green)
# add a legent to the plot
legend(
'topleft',
inset = .05,
legend = c(
"f1",
"f2"
),
col = c('#2196f3', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
# return xx and yy (just in case)
return(cbind(xx, yy))
}
# ODEs to be evaluated: P -> x ; N -> y ;
myFunction <- function(t, y, p) {
N <- y[1]
P <- y[2]
with(as.list(p), {
dNdt <- c * N - d * P * N
dPdt <- -a * P + b * P * N
return(list(c(dNdt, dPdt)))
})
}
# ODEs' coefficients:
a <- 0.16
b <- 0.08
c <- 4.5
d <- 0.9
# ODEs' coefficients/parameters:
p <- c(a = a,
b = b,
c = c,
d = d)
# Initial conditions: P -> x ; N -> y ;
y0 <- c(N = 4, P = 4)
# time vector: to define t0, tf, and the step size
times <- seq(0, 12, 0.1) # time unit = months
out <- rungeKutta4_2eq(y0, times, myFunction, p)
# ODEs to be evaluated: P -> x ; N -> y ;
predpreyLV <- function(t, y, p) {
N <- y[1]
P <- y[2]
with(as.list(p), {
dNdt <- c * N - d * P * N
dPdt <- -a * P + b * P * N
return(list(c(dNdt, dPdt)))
})
}
# ODEs' coefficients:
a <- 16
b <- 0.08
c <- 4.5
d <- 0.9
# ODEs' coefficients/parameters:
p <- c(a = a,
b = b,
c = c,
d = d)
# Initial conditions: P -> x ; N -> y ;
y0 <- c(N = 4, P = 4)
# time vector: to define t0, tf, and the step size
times <- seq(0, 2, 0.01) # time unit = years
out <- rungeKutta4_2eq(y0, times, predpreyLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, predpreyLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", xlab = "t", ylab = "population")
LV.out <- ode(y = y0, times, predpreyLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l",main = 'deSolve Approximation', xlab = "t", ylab = "population")
# ODEs to be evaluated: P -> x ; N -> y ;
watertanksLV <- function(t, y, p) {
N <- y[1]
P <- y[2]
with(as.list(p), {
dNdt <- c * P - d * N
dPdt <- -a * P + b * N
return(list(c(dNdt, dPdt)))
})
}
# ODEs' coefficients:
a <- (2 / 25)
b <- (1 / 50)
c <- (2 / 25)
d <- (2 / 25)
# ODEs' coefficients/parameters:
p <- c(a = a,
b = b,
c = c,
d = d)
# Initial conditions: P -> x ; N -> y ;
y0 <- c(N = 0, P = 25)
# time vector: to define t0, tf, and the step size
times <- seq(0, 600, 1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
# add a legent to the plot
legend(
'topleft',
inset = .05,
legend = c(
"f1",
"f2"
),
col = c('#4caf50','#2196f3'),
lwd = c(1),
bty = 'n',
cex = .75
)
# return xx and yy (just in case)
return(cbind(xx, yy))
# Runge-Kutta - 4th order - for a 2-equation 1st order system
rungeKutta4_2eq <- function(y0, times, funct, p) {
# create xx and yy to store the RK calculations for each step
xx <- double(length(times) - 1)
xx[1] <- xn <- y0[1]
yy <- double(length(times) - 1)
yy[1] <- yn <- y0[2]
# get the step size h
h <- (max(times) - min(times)) / length(times)
i = 2 # start populating the 2nd element of xx and yy. the 1st ones are y0
for (tn in times) {
# from https://www.calvin.edu/~scofield/courses/m231/materials/rungeKuttaFormulas.pdf
# and https://math.stackexchange.com/questions/721076/help-with-using-the-runge-kutta-4th-order-method-on-a-system-of-2-first-order-od
# compute the RK constants k and l
kn1 = funct(tn, xn, yn)[[1]][[1]]
ln1 = funct(tn, xn, yn)[[1]][[2]]
kn2 = funct(
tn + h / 2,
xn + (1 / 2) * kn1 * h,
yn + (1 / 2) * ln1 * h)[[1]][[1]]
ln2 = funct(
tn + h / 2,
xn + (1 / 2) * kn1 * h,
yn + (1 / 2) * ln1 * h)[[1]][[2]]
kn3 = funct(
tn + h / 2,
xn + (1 / 2) * kn2 * h,
yn + (1 / 2) * ln2 * h)[[1]][[1]]
ln3 = funct(
tn + h / 2,
xn + (1 / 2) * kn2 * h,
yn + (1 / 2) * ln2 * h)[[1]][[2]]
kn4 = funct(tn + h, xn + kn3 * h, yn + ln3 * h)[[1]][[1]]
ln4 = funct(tn + h, xn + kn3 * h, yn + ln3 * h)[[1]][[2]]
# store the calculated xn and yn within xx and yy respectively
xx[i] = as.numeric(xn)
yy[i] = as.numeric(yn)
# update xn and yn
xn <- xn + h * (kn1 + 2 * kn2 + 2 * kn3 + kn4) / 6
yn <- yn + h * (ln1 + 2 * ln2 + 2 * ln3 + ln4) / 6
# update the index i to avoid overwriting in xx and yy
i = i + 1
}
# remove the last element within xx and yy,
# their length shall match times's length to plot
xx = xx[-length(times + 1)]
yy = yy[-length(times + 1)]
# mmin and mmax are the plot y-limits
mmin = as.numeric(min(xx))
mmax = as.numeric(max(xx))
mmin <- if (mmin > min(yy))
min(yy)
else
mmin
mmax <- if (mmax < max(yy))
max(yy)
else
mmax
# plot xx
plot(
times,
xx,
xlab = "t",
ylab = "f(t)",
type = "l",
main = ' Runge-Kutta ',
col = "#2196f3", # (blue)
lwd = 1,
ylim = c(mmin, mmax)
)
# plot yy in the same image
lines(times, yy, col = "#4caf50") # (green)
# add a legent to the plot
legend(
'topleft',
inset = .05,
legend = c(
"f1",
"f2"
),
col = c('#4caf50','#2196f3'),
lwd = c(1),
bty = 'n',
cex = .75
)
# return xx and yy (just in case)
return(cbind(xx, yy))
}
# ODEs to be evaluated: P -> x ; N -> y ;
myFunction <- function(t, y, p) {
N <- y[1]
P <- y[2]
with(as.list(p), {
dNdt <- c * N - d * P * N
dPdt <- -a * P + b * P * N
return(list(c(dNdt, dPdt)))
})
}
# ODEs' coefficients:
a <- 0.16
b <- 0.08
c <- 4.5
d <- 0.9
# ODEs' coefficients/parameters:
p <- c(a = a,
b = b,
c = c,
d = d)
# Initial conditions: P -> x ; N -> y ;
y0 <- c(N = 4, P = 4)
# time vector: to define t0, tf, and the step size
times <- seq(0, 12, 0.1) # time unit = months
out <- rungeKutta4_2eq(y0, times, myFunction, p)
# ODEs to be evaluated: P -> x ; N -> y ;
predpreyLV <- function(t, y, p) {
N <- y[1]
P <- y[2]
with(as.list(p), {
dNdt <- c * N - d * P * N
dPdt <- -a * P + b * P * N
return(list(c(dNdt, dPdt)))
})
}
# ODEs' coefficients:
a <- 16
b <- 0.08
c <- 4.5
d <- 0.9
# ODEs' coefficients/parameters:
p <- c(a = a,
b = b,
c = c,
d = d)
# Initial conditions: P -> x ; N -> y ;
y0 <- c(N = 4, P = 4)
# time vector: to define t0, tf, and the step size
times <- seq(0, 2, 0.01) # time unit = years
out <- rungeKutta4_2eq(y0, times, predpreyLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, predpreyLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l",main = 'deSolve Approximation', xlab = "t", ylab = "population")
# ODEs to be evaluated: P -> x ; N -> y ;
watertanksLV <- function(t, y, p) {
N <- y[1]
P <- y[2]
with(as.list(p), {
dNdt <- c * P - d * N
dPdt <- -a * P + b * N
return(list(c(dNdt, dPdt)))
})
}
# ODEs' coefficients:
a <- (2 / 25)
b <- (1 / 50)
c <- (2 / 25)
d <- (2 / 25)
# ODEs' coefficients/parameters:
p <- c(a = a,
b = b,
c = c,
d = d)
# Initial conditions: P -> x ; N -> y ;
y0 <- c(N = 0, P = 25)
# time vector: to define t0, tf, and the step size
times <- seq(0, 600, 1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", ylab = "gallons")
LV.out <- ode(y = y0, times, watertanksLV, p)
#*******************************************************************************
# ODEs to be evaluated: P -> x ; N -> y ;
watertanksLV <- function(t, y, p) {
N <- y[1]
P <- y[2]
with(as.list(p), {
dNdt <- c * P - d * N
dPdt <- -a * P + b * N
return(list(c(dNdt, dPdt)))
})
}
# ODEs' coefficients:
a <- (2 / 25)
b <- (1 / 50)
c <- (2 / 25)
d <- (2 / 25)
# ODEs' coefficients/parameters:
p <- c(a = a,
b = b,
c = c,
d = d)
# Initial conditions: P -> x ; N -> y ;
y0 <- c(N = 0, P = 25)
# time vector: to define t0, tf, and the step size
times <- seq(0, 600, 1) # time unit = minutes
out <- rungeKutta4_2eq(y0, times, watertanksLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, watertanksLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l", main = 'deSolve Approximation', ylab = "gallons")
# ODEs to be evaluated: P -> x ; N -> y ;
predpreyLV <- function(t, y, p) {
N <- y[1]
P <- y[2]
with(as.list(p), {
dNdt <- c * N - d * P * N
dPdt <- -a * P + b * P * N
return(list(c(dNdt, dPdt)))
})
}
# ODEs' coefficients:
a <- 16
b <- 0.08
c <- 4.5
d <- 0.9
# ODEs' coefficients/parameters:
p <- c(a = a,
b = b,
c = c,
d = d)
# Initial conditions: P -> x ; N -> y ;
y0 <- c(N = 4, P = 4)
# time vector: to define t0, tf, and the step size
times <- seq(0, 2, 0.01) # time unit = years
out <- rungeKutta4_2eq(y0, times, predpreyLV, p)
library(deSolve)
library(lattice) # to plot using matplot
LV.out <- ode(y = y0, times, predpreyLV, p)
matplot(LV.out[, 1], LV.out[, 2:3], type = "l",main = 'deSolve Approximation', xlab = "t", ylab = "population")
