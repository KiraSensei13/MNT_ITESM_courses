# Plot of the second, third and fourth order RK approximations
#
# Parameters
# ----------
# func : string
# ODE function of two variabless
# x0, y0 : numeric
# initial values
# x1 : numeric
# upper bound
# n : numeric
# number of steps
# plot_ymin, plot_ymax : numeric
# set the plot y-axis range
#
# Returns
# -------
# void
# Calculate aproxminations
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <-
seq(init_x,
upper_bound,
length(init_x:upper_bound) / number_of_steps)
plot(
out_1,
xlab = "x",
ylab = "f'(x)",
type = "l",
main = ' Runge-Kutta ',
col = "black",
lwd = 2,
ylim=c(plot_ymin,plot_ymax)
)
# RK4 function 1
lines(x4_1, y4_1, col = "#42a5f5") # blue lighten-1
# deSolve function 2
lines(out_2, col = "#b71c1c", lwd = 2) # blue lighten-1
# RK4 function 2
lines(x4_2, y4_2, col = "#e53935") # red darken-1
legend(
'topleft',
inset = .05,
legend = c(
lwd = c(1),
bty = 'n',
cex = .75
)
}
funct_2 = "4.5*y - 0.9*x*y"
# Enter Y initial Value:
init_y = 4
# Enter X initial Value:
init_x = 4
# Enter Upper bound
library (deSolve)
RKPlot2 <-
function(func_1,
func_2,
x0,
y0,
x1,
n,
plot_ymin,
plot_ymax) {
# Plot of the second, third and fourth order RK approximations
#
# Parameters
# ----------
# func : string
# ODE function of two variabless
# x0, y0 : numeric
# initial values
# x1 : numeric
# upper bound
# n : numeric
# number of steps
# plot_ymin, plot_ymax : numeric
# set the plot y-axis range
#
# Returns
# -------
# void
# Calculate aproxminations
rk4_1 = rungeKutta4(func_1, x0, y0, x1, n)
rk4_2 = rungeKutta4(func_2, x0, y0, x1, n)
x4_1 <- rk4_1[, 1]
y4_1 <- rk4_1[, 2]
x4_2 <- rk4_2[, 1]
y4_2 <- rk4_2[, 2]
# Compute analytical answer of the ODE approximations
model_1 <- function(x, y, parms) {
with(as.list(c(y, parms)), {
dy = eval(parse(text = funct_1), envir = list(x, y))#2*x^3 + y
list(dy)
})
# ODEs to be evaluated (enter it as a string):
funct_1 = "-0.16*x + 0.08*x*y"
funct_2 = "4.5*y - 0.9*x*y"
# Enter Y initial Value:
init_y = 4
# Enter X initial Value:
init_x = 4
# Enter Upper bound
RKPlot2 <-
function(func_1,
func_2,
x0,
y0,
x1,
n,
plot_ymin,
plot_ymax) {
# Plot of the second, third and fourth order RK approximations
#
# Parameters
# ----------
# func : string
# ODE function of two variabless
# x0, y0 : numeric
# initial values
# x1 : numeric
# upper bound
# n : numeric
# number of steps
# plot_ymin, plot_ymax : numeric
# set the plot y-axis range
#
# Returns
# -------
# void
# Calculate aproxminations
rk4_1 = rungeKutta4(func_1, x0, y0, x1, n)
rk4_2 = rungeKutta4(func_2, x0, y0, x1, n)
x4_1 <- rk4_1[, 1]
y4_1 <- rk4_1[, 2]
x4_2 <- rk4_2[, 1]
y4_2 <- rk4_2[, 2]
# Compute analytical answer of the ODE approximations
model_1 <- function(x, y, parms) {
with(as.list(c(y, parms)), {
dy = eval(parse(text = funct_1), envir = list(x, y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <-
seq(init_x,
upper_bound,
length(init_x:upper_bound) / number_of_steps)
out_1 <- ode(y, times = x, model_1, parms)
model_2 <- function(x, y, parms) {
with(as.list(c(y, parms)), {
dy = eval(parse(text = funct_2), envir = list(x, y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <-
seq(init_x,
upper_bound,
length(init_x:upper_bound) / number_of_steps)
out_2 <- ode(y, times = x, model_2, parms)
### Plot
# deSolve function 1
plot(
out_1,
xlab = "x",
ylab = "f'(x)",
type = "l",
main = ' Runge-Kutta ',
col = "black",
lwd = 2,
ylim=c(plot_ymin,plot_ymax)
)
# RK4 function 1
lines(x4_1, y4_1, col = "#42a5f5") # blue lighten-1
# deSolve function 2
lines(out_2, col = "#b71c1c", lwd = 2) # blue lighten-1
# RK4 function 2
lines(x4_2, y4_2, col = "#e53935") # red darken-1
legend(
'topleft',
inset = .05,
legend = c(
"deSolve function 1",
"RK4 function 1",
"deSolve function 2",
"RK4 function 2"
),
col = c('#0d47a1', '#42a5f5', '#b71c1c', '#e53935'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
funct_2 = "4.5*y - 0.9*x*y"
# Enter Y initial Value:
init_y = 4
# Enter X initial Value:
init_x = 4
# Enter Upper bound
# Calling the function for the solution:
RKPlot2(funct_1,
funct_2,
init_x,
init_y,
upper_bound,
number_of_steps,