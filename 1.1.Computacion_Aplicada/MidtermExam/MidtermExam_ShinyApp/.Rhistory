choco_data$chocolate <- as.factor(choco_data$chocolate)
summary(choco_data)
# Since the dependent variable "Chocolate" is a categorical variable, we have decided to use Logistic Regression:
mdl <- glm(chocolate ~ ., data = choco_data, family = "binomial")
summary(mdl)
mdl <- glm(chocolate ~ fruity + caramel +  peanutyalmondy + nougat + crispedricewafer + hard + bar + pluribus + sugarpercent + pricepercent + winpercent, data = choco_data, family = "binomial")
summary(mdl) # Visualizing the model to determine the most significant variables.
## Part 1
library(faraway)
data(pima)
# Exploration
summary(pima)
# Apply filter by filter
index = pima$glucose > 0
pima = pima[ index,  ]
index = pima$diastolic > 0
pima = pima[ index,  ]
index = pima$insulin > 0
pima = pima[ index,  ]
# Setting numeric values to categoric value:
choco_data$chocolate <- as.factor(choco_data$chocolate)
summary(choco_data)
?factor
?levels()
?labels()
?label()
mdl <- glm(chocolate ~ competitorname +fruity + caramel +  peanutyalmondy + nougat + crispedricewafer + hard + bar + pluribus + sugarpercent + pricepercent + winpercent, data = choco_data, family = "binomial")
summary(mdl) # Visualizing the model to determine the most significant variables.
# First we define a variable to call for the database to be analized:
choco_data = read.csv("Chocolate.csv")
str(choco_data) # Verifying there is no repeated information.
summary(choco_data) # Exploring the data.
chocolate_labels <- choco_data[,1]
# Setting numeric values to categoric value:
choco_data$chocolate <- as.factor(choco_data$chocolate)
summary(choco_data)
# First we define a variable to call for the database to be analized:
choco_data = read.csv("Chocolate.csv")
str(choco_data) # Verifying there is no repeated information.
summary(choco_data) # Exploring the data.
chocolate_labels <- choco_data[,1]
choco_data <- choco_data[,-1]
# Setting numeric values to categoric value:
choco_data$chocolate <- as.factor(choco_data$chocolate)
summary(choco_data)
# Since the dependent variable "Chocolate" is a categorical variable, we have decided to use Logistic Regression:
mdl <- glm(chocolate ~ ., data = choco_data, family = "binomial")
summary(mdl)
mdl <- glm(chocolate ~ fruity + caramel +  peanutyalmondy + nougat + crispedricewafer + hard + bar + pluribus + sugarpercent + pricepercent + winpercent, data = choco_data, family = "binomial")
summary(mdl) # Visualizing the model to determine the most significant variables.
# Lets see the performance of our beta coefficients:
predicted <- predict(mdl, choco_data[,], type = "response")
hist(predicted)
# First we define a variable to call for the database to be analized:
choco_data = read.csv("Chocolate.csv")
str(choco_data) # Verifying there is no repeated information.
summary(choco_data) # Exploring the data.
chocolate_labels <- choco_data[,1]
choco_data <- choco_data[,-1]
# Setting numeric values to categoric value:
choco_data$chocolate <- as.factor(choco_data$chocolate)
summary(choco_data)
# Since the dependent variable "Chocolate" is a categorical variable, we have decided to use Logistic Regression:
mdl <- glm(chocolate ~ ., data = choco_data, family = "binomial")
summary(mdl)
mdl <- glm(chocolate ~ fruity + caramel +  peanutyalmondy + nougat + crispedricewafer + hard + bar + pluribus + sugarpercent + pricepercent + winpercent, data = choco_data, family = "binomial")
summary(mdl) # Visualizing the model to determine the most significant variables.
# Lets see the performance of our beta coefficients:
predicted <- predict(mdl, choco_data[,], type = "response")
hist(predicted)
mdl <- glm(chocolate ~ fruity + winpercent, data = choco_data, family = "binomial")
summary(mdl) # Visualizing the model to determine the most significant variables.
mdl <- glm(chocolate ~ fruity + caramel +  peanutyalmondy + nougat + crispedricewafer + hard + bar + pluribus + sugarpercent + pricepercent + winpercent, data = choco_data, family = "binomial")
summary(mdl) # Visualizing the model to determine the most significant variables.
mdl <- glm(chocolate ~ fruity + winpercent, data = choco_data, family = "binomial")
summary(mdl) # Visualizing the model to determine the most significant variables.
# Lets see the performance of our beta coefficients:
predicted <- predict(mdl, choco_data[,], type = "response")
hist(predicted)
#We assume that: all values less than 0.5 correspond to the first category, 0.5 or bigger correspond to the second category
glm_predicted = ifelse(predicted > 0.5, 1, 0)
hist(glm_predicted)
taylorPlot <- function(f, c, from, to) {
# Plot the Taylor approximations up to the 2nd, 4th, 6th and 8th terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# c : numeric
# point where the series expansion will take place
# from, to : numeric
# Interval of points to be ploted
#
# Returns
# -------
# void
x <- seq(from, to, length.out = 100)
yf <- f(x)
yp2 <- polyval(taylor(f, c, 2), x)
yp4 <- polyval(taylor(f, c, 4), x)
yp6 <- polyval(taylor(f, c, 6), x)
yp8 <- polyval(taylor(f, c, 8), x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp2, col = "#c8e6c9")
lines(x, yp4, col = "#81c784")
lines(x, yp6, col = "#4caf50")
lines(x, yp8, col = "#388e3c")
legend(
'topleft',
inset = .05,
legend = c("TS 8 terms", "TS 6 terms", "TS 4 terms", "TS 2 terms", "f(x)"),
col = c('#388e3c', '#4caf50', '#81c784', '#c8e6c9', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
f0 <- function(x) {
res = sin(x)
return(res)
}
f1 <- function(x) {
res = exp(complex(real = 0, imaginary = 1)*x)
return(res)
}
taylorPlot(f0, 0, -6.6, 6.6)
taylorPlot(f1, 1, -2*pi, 2*pi)
library(pracma)
taylorPlot <- function(f, c, from, to) {
# Plot the Taylor approximations up to the 2nd, 4th, 6th and 8th terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# c : numeric
# point where the series expansion will take place
# from, to : numeric
# Interval of points to be ploted
#
# Returns
# -------
# void
x <- seq(from, to, length.out = 100)
yf <- f(x)
yp2 <- polyval(taylor(f, c, 2), x)
yp4 <- polyval(taylor(f, c, 4), x)
yp6 <- polyval(taylor(f, c, 6), x)
yp8 <- polyval(taylor(f, c, 8), x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp2, col = "#c8e6c9")
lines(x, yp4, col = "#81c784")
lines(x, yp6, col = "#4caf50")
lines(x, yp8, col = "#388e3c")
legend(
'topleft',
inset = .05,
legend = c("TS 8 terms", "TS 6 terms", "TS 4 terms", "TS 2 terms", "f(x)"),
col = c('#388e3c', '#4caf50', '#81c784', '#c8e6c9', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
f0 <- function(x) {
res = sin(x)
return(res)
}
f1 <- function(x) {
res = exp(complex(real = 0, imaginary = 1)*x)
return(res)
}
taylorPlot(f0, 0, -6.6, 6.6)
taylorPlot(f1, 1, -2*pi, 2*pi)
?pracma
# First we define a variable to call for the database to be analized:
choco_data = read.csv("Chocolate.csv")
str(choco_data) # Verifying there is no repeated information.
summary(choco_data) # Exploring the data.
chocolate_labels <- choco_data[,1]
choco_data <- choco_data[,-1]
# Setting numeric values to categoric value:
choco_data$chocolate <- as.factor(choco_data$chocolate)
library(pracma)
taylorPlot <- function(f, c, from, to) {
# Plot the Taylor approximations up to the 2nd, 4th, 6th and 8th terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# c : numeric
# point where the series expansion will take place
# from, to : numeric
# Interval of points to be ploted
#
# Returns
# -------
# void
x <- seq(from, to, length.out = 100)
yf <- f(x)
yp2 <- polyval(taylor(f, c, 2), x)
yp4 <- polyval(taylor(f, c, 4), x)
yp6 <- polyval(taylor(f, c, 6), x)
yp8 <- polyval(taylor(f, c, 8), x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp2, col = "#c8e6c9")
lines(x, yp4, col = "#81c784")
lines(x, yp6, col = "#4caf50")
lines(x, yp8, col = "#388e3c")
legend(
'topleft',
inset = .05,
legend = c("TS 8 terms", "TS 6 terms", "TS 4 terms", "TS 2 terms", "f(x)"),
col = c('#388e3c', '#4caf50', '#81c784', '#c8e6c9', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
f0 <- function(x) {
res = sin(x)
return(res)
}
f1 <- function(x) {
res = exp(complex(real = 0, imaginary = 1)*x)
return(res)
}
taylorPlot(f0, 0, -6.6, 6.6)
taylorPlot(f1, 1, -2*pi, 2*pi)
library(pracma)
taylorPlot <- function(f, c, from, to) {
# Plot the Taylor approximations up to the 2nd, 4th, 6th and 8th terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# c : numeric
# point where the series expansion will take place
# from, to : numeric
# Interval of points to be ploted
#
# Returns
# -------
# void
x <- seq(from, to, length.out = 100)
yf <- f(x)
yp2 <- polyval(taylor(f, c, 2), x)
yp4 <- polyval(taylor(f, c, 4), x)
yp6 <- polyval(taylor(f, c, 6), x)
yp8 <- polyval(taylor(f, c, 8), x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp2, col = "#c8e6c9")
lines(x, yp4, col = "#81c784")
lines(x, yp6, col = "#4caf50")
lines(x, yp8, col = "#388e3c")
legend(
'topleft',
inset = .05,
legend = c("TS 8 terms", "TS 6 terms", "TS 4 terms", "TS 2 terms", "f(x)"),
col = c('#388e3c', '#4caf50', '#81c784', '#c8e6c9', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
# Asking for input from the user to obtain the Taylor Series Approximation from the desired function:
f <- readline(prompt="Enter desired function in terms of x to be approximated using Taylor Series: ")
f0 <- function(x) {
res = f
return(res)
}
# Asking for the point of interest to make the approximation and the maximum and minimum x values to visualize in the plot:
p0 <- readline(prompt="Enter the x value for the point of approximation: ")
xmin <- readline(prompt="Enter minimum x value to visualize in the graph: ")
xmax <- readline(prompt="Enter minimum x value to visualize in the graph: ")
# Convert characters into integers:
p0 <- as.integer(p0)
p0 <- as.integer(xmin)
p0 <- as.integer(xmax)
print(paste("Hi, the taylor approximation for the entered funcion: ", f, " can be visualized in the graph on the right."))
taylorPlot(f0, p0, xmin, xmax)
taylorPlot(f0, p0, xmin, xmax)
library(pracma)
taylorPlot <- function(f, c, from, to) {
# Plot the Taylor approximations up to the 2nd, 4th, 6th and 8th terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# c : numeric
# point where the series expansion will take place
# from, to : numeric
# Interval of points to be ploted
#
# Returns
# -------
# void
x <- seq(from, to, length.out = 100)
yf <- f(x)
yp2 <- polyval(taylor(f, c, 2), x)
yp4 <- polyval(taylor(f, c, 4), x)
yp6 <- polyval(taylor(f, c, 6), x)
yp8 <- polyval(taylor(f, c, 8), x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp2, col = "#c8e6c9")
lines(x, yp4, col = "#81c784")
lines(x, yp6, col = "#4caf50")
lines(x, yp8, col = "#388e3c")
legend(
'topleft',
inset = .05,
legend = c("TS 8 terms", "TS 6 terms", "TS 4 terms", "TS 2 terms", "f(x)"),
col = c('#388e3c', '#4caf50', '#81c784', '#c8e6c9', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
# Asking for input from the user to obtain the Taylor Series Approximation from the desired function:
f <- readline(prompt="Enter desired function in terms of x to be approximated using Taylor Series: ")
library(pracma)
taylorPlot <- function(f, c, from, to) {
# Plot the Taylor approximations up to the 2nd, 4th, 6th and 8th terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# c : numeric
# point where the series expansion will take place
# from, to : numeric
# Interval of points to be ploted
#
# Returns
# -------
# void
x <- seq(from, to, length.out = 100)
yf <- f(x)
yp2 <- polyval(taylor(f, c, 2), x)
yp4 <- polyval(taylor(f, c, 4), x)
yp6 <- polyval(taylor(f, c, 6), x)
yp8 <- polyval(taylor(f, c, 8), x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp2, col = "#c8e6c9")
lines(x, yp4, col = "#81c784")
lines(x, yp6, col = "#4caf50")
lines(x, yp8, col = "#388e3c")
legend(
'topleft',
inset = .05,
legend = c("TS 8 terms", "TS 6 terms", "TS 4 terms", "TS 2 terms", "f(x)"),
col = c('#388e3c', '#4caf50', '#81c784', '#c8e6c9', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
# Asking for input from the user to obtain the Taylor Series Approximation from the desired function:
f0 <- readline(prompt="Enter desired function in terms of x to be approximated using Taylor Series: ")
res = f0
return(res)
}
# Asking for the point of interest to make the approximation and the maximum and minimum x values to visualize in the plot:
p0 <- readline(prompt="Enter the x value for the point of approximation: ")
xmax <- readline(prompt="Enter minimum x value to visualize in the graph: ")
p0 <- as.integer(p0)
install.packages("shiny")
library(shiny)
library(shiny)
shinyUI(
pageWithSidebar(
headerPanel("Midterm Exam"),
sidebarPanel("User Input"),
mainPanel("Problem Results")
)
)
setwd("C:/Git/MNT_ITESM_courses/1.1.Computacion_Aplicada/MidtermExam/MidtermExam_ShinyApp")
runApp()
setwd("C:/Git/MNT_ITESM_courses/1.1.Computacion_Aplicada/MidtermExam/MidtermExam_ShinyApp")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?pageWithSidebar
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?textOutput()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?ifelse
?for
}
}
?for (variable in vector) {
}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?while
runApp()
runApp()
runApp()
runApp()
