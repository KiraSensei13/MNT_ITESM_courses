numericInput("p", "Please enter the point x to which you want to approximate: ", 0),
numericInput("xmin", "Please enter lower value of x: ", -6),
numericInput("xmax", "Please enter upper value of x:", 6),
sliderInput("factors", "Please select number of factors:",
min = 1, max = 5000, value = 1, step = 1)),
conditionalPanel(
condition = "input.ExamProblems == 'Second Section - Problem c)'")
),
########### THIS IS WHERE THE INFORMATION WILL BE SHOWN ########################
mainPanel(
# Displaying the information in tabs:
tabsetPanel(type="tab",
tabPanel("Solution",
tags$b(paste("Instructions:")),
textOutput("Problem Instructions"),
plotOutput("Graphical Representation")),
tabPanel("Code", verbatimTextOutput("Code")),
tabPanel("Chocolate",
tableOutput("Chocolate"))
)
)
)
server <- function (input,output,session){
########### THIS SECTION IS JUST FOR THE INSTRUCTIONS OF EACH PROBLEM ##########
output$`Problem Instructions` <- renderText({
problemId <- input$`ExamProblems`
if (problemId == "First Section - Problem 1 a)"){
instructions <- "Database: Chocolate.
Dependent variable: Chocolate -> (Chocolate is a categorical variable)
Choose only the most significant variables to model the dependent variable. (10 points)"
}
else{
if (problemId == "Second Section - Problem a)"){
instructions <- "Lagrange polynomials. This algorithm receives a nx2 matrix, where the first column represents the x coordinate while the second column represents the y coordinate. The code must provide as output the Lagrange polynomial interpolation expression in terms of x. (30 points) *TIP: Use the functions: expression, D, parse and paste within a loop to get the desired output."
}
else{
if (problemId == "Second Section - Problem b)"){
instructions <- "Taylor series: The algorithm receives an expression or a string with the function to do and the number of terms to get. The output will be an expression containing all the Taylor series about 0. (30 points) *TIP: Use the functions: expression, D, parse and paste within a loop to get the desired output."
}
else{
if (problemId == "Second Section - Problem c)"){
instructions <- "Runge-Kutta. The algorithm will receive an ODE, initial values for x and y, the step size and the upper bound. The output will be the plot of the second, third and fourth order RK approximations. To demonstrate the functionality of your code, use the analytical answer of the ODE to compare all the approximations (30 points)"
}
else {
instructions <- "Sorry for the inconvenience, we are still working hard to make this application evenn better."
}
}
}
}
paste(instructions)
})
########### THIS SECTION IS TO ADD THE CODE (PROCEDURE) ########################
output$`Code` <- renderPrint({
problemId <- input$`ExamProblems`
######## Procedure for problem 1 ########################
if (problemId == "First Section - Problem 1 a)") {
}
else{
}
######## Procedure for problem 2 ##############################################
if (problemId == "Second Section - Problem a)") {
}
else{
}
######## Procedure for problem 3 ##############################################
if (problemId == "Second Section - Problem b)") {
library(pracma)
taylorPlot <- function(f, c, from, to) {
# Plot the Taylor approximations up to the 2nd, 4th, 6th and 8th terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# c : numeric
# point where the series expansion will take place
# from, to : numeric
# Interval of points to be ploted
#
# Returns
# -------
# void
x <- seq(from, to, length.out = 100)
yf <- f(x)
yp2 <- polyval(taylor(f, c, 2), x)
yp4 <- polyval(taylor(f, c, 4), x)
yp6 <- polyval(taylor(f, c, 6), x)
yp8 <- polyval(taylor(f, c, 8), x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp2, col = "#c8e6c9")
lines(x, yp4, col = "#81c784")
lines(x, yp6, col = "#4caf50")
lines(x, yp8, col = "#388e3c")
legend(
'topleft',
inset = .05,
legend = c("TS 8 terms", "TS 6 terms", "TS 4 terms", "TS 2 terms", "f(x)"),
col = c('#388e3c', '#4caf50', '#81c784', '#c8e6c9', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
f0 <- function(x) {
res = sin(x)
return(res)
}
f1 <- function(x) {
res = exp(complex(real = 0, imaginary = 1)*x)
return(res)
}
}
else{
}
######## Procedure for Problem 4 ############################################
if (problemId == "Second Section - Problem c)"){
}
else{
}
})
########### THIS SECTION IS FOR THE PLOTS CREATED BY THE PROGRAM ###############
output$`Graphical Representation` <- renderPlot({
problemId <- input$`ExamProblems`
############## Plot for Problem 1 ##############################################
if (problemId == "First Section - Problem 1 a)") {
choco_data = read.csv("Chocolate.csv")
chocolate_labels <- choco_data[,1]
choco_data <- choco_data[,-1]
choco_data$chocolate <- as.factor(choco_data$chocolate)
mdl <- glm(chocolate ~ ., data = choco_data, family = "binomial")
mdl <- glm(chocolate ~ fruity + winpercent, data = choco_data, family = "binomial")
predicted <- predict(mdl, choco_data[,], type = "response")
glm_predicted = ifelse(predicted > 0.5, 1, 0)
graph <- hist(glm_predicted, main = "Histogram of Chocolate Frequency in Candy", ylab = "Frequency of Trait", xlab = "Presence of Chocolate", ylim = c(0, 60), labels = TRUE)
}
else{
############## Plot for Problem 2 ##############################################
if (problemId == "Second Section - Problem a)") {
}
else{
############## Plot for problem 3 ##############################################
if (problemId == "Second Section - Problem b)") {
}
else{
############## Plot for problem 4 ##############################################
if (problemId == "Second Section - Problem c)") {
}
else{
graph <- "Sorry for the inconvenience, we are still working hard to make this application evenn better."
}
}
}
}
paste(graph)
})
########### THIS SECTION CORRESPONDS ONLY TO THE CHOCOLATE DATA ################
output$`Chocolate` <- renderTable({
choco_data = read.csv("Chocolate.csv")
choco_data
})
}
shinyApp(ui = ui, server = server)
runApp()
setwd("C:/Git/MNT_ITESM_courses/1.1.Computacion_Aplicada/MidtermExam/MidtermExam_ShinyApp")
runApp()
# Defining the user interface:
ui <- fluidPage(
########### STYLE ##############################################################
# Defining style:
theme = shinytheme("sandstone"),
########### HEADER OF THE APPLICATION ##########################################
titlePanel(h1("Midterm Exam", align = "center")),
titlePanel(h5("by: Antonio Osamu Katagiri Tanaka (A01212611) and Bruno Gonzalez Soria (A01169284)", align = "center")),
########### THIS IS THE SIDE PANEL FOR THE USER TO ENTER INPUT #################
sidebarPanel(
selectInput("ExamProblems", "Please Select the problem to be evaluated:",
choices = c("First Section - Problem 1 a)", "Second Section - Problem a)", "Second Section - Problem b)", "Second Section - Problem c)")),
conditionalPanel(
condition = "input.ExamProblems == 'First Section - Problem 1 a)'"),
conditionalPanel(
condition = "input.ExamProblems == 'Second Section - Problem a)'"),
conditionalPanel(
condition = "input.ExamProblems == 'Second Section - Problem b)'",
numericInput("p", "Please enter the point x to which you want to approximate: ", 0),
numericInput("xmin", "Please enter lower value of x: ", -6),
numericInput("xmax", "Please enter upper value of x:", 6),
sliderInput("factors", "Please select number of factors:",
min = 1, max = 5000, value = 1, step = 1)),
conditionalPanel(
condition = "input.ExamProblems == 'Second Section - Problem c)'")
),
########### THIS IS WHERE THE INFORMATION WILL BE SHOWN ########################
mainPanel(
# Displaying the information in tabs:
tabsetPanel(type="tab",
tabPanel("Solution",
tags$b(paste("Instructions:")),
textOutput("Problem Instructions"),
plotOutput("Graphical Representation")),
tabPanel("Code", verbatimTextOutput("Code")),
tabPanel("Chocolate",
tableOutput("Chocolate"))
)
)
)
server <- function (input,output,session){
########### THIS SECTION IS JUST FOR THE INSTRUCTIONS OF EACH PROBLEM ##########
output$`Problem Instructions` <- renderText({
problemId <- input$`ExamProblems`
if (problemId == "First Section - Problem 1 a)"){
instructions <- "Database: Chocolate.
Dependent variable: Chocolate -> (Chocolate is a categorical variable)
Choose only the most significant variables to model the dependent variable. (10 points)"
}
else{
if (problemId == "Second Section - Problem a)"){
instructions <- "Lagrange polynomials. This algorithm receives a nx2 matrix, where the first column represents the x coordinate while the second column represents the y coordinate. The code must provide as output the Lagrange polynomial interpolation expression in terms of x. (30 points) *TIP: Use the functions: expression, D, parse and paste within a loop to get the desired output."
}
else{
if (problemId == "Second Section - Problem b)"){
instructions <- "Taylor series: The algorithm receives an expression or a string with the function to do and the number of terms to get. The output will be an expression containing all the Taylor series about 0. (30 points) *TIP: Use the functions: expression, D, parse and paste within a loop to get the desired output."
}
else{
if (problemId == "Second Section - Problem c)"){
instructions <- "Runge-Kutta. The algorithm will receive an ODE, initial values for x and y, the step size and the upper bound. The output will be the plot of the second, third and fourth order RK approximations. To demonstrate the functionality of your code, use the analytical answer of the ODE to compare all the approximations (30 points)"
}
else {
instructions <- "Sorry for the inconvenience, we are still working hard to make this application evenn better."
}
}
}
}
paste(instructions)
})
########### THIS SECTION IS TO ADD THE CODE (PROCEDURE) ########################
output$`Code` <- renderPrint({
problemId <- input$`ExamProblems`
######## Procedure for problem 1 ########################
if (problemId == "First Section - Problem 1 a)") {
}
else{
}
######## Procedure for problem 2 ##############################################
if (problemId == "Second Section - Problem a)") {
}
else{
}
######## Procedure for problem 3 ##############################################
if (problemId == "Second Section - Problem b)") {
library(pracma)
taylorPlot <- function(f, c, from, to) {
# Plot the Taylor approximations up to the 2nd, 4th, 6th and 8th terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# c : numeric
# point where the series expansion will take place
# from, to : numeric
# Interval of points to be ploted
#
# Returns
# -------
# void
x <- seq(from, to, length.out = 100)
yf <- f(x)
yp2 <- polyval(taylor(f, c, 2), x)
yp4 <- polyval(taylor(f, c, 4), x)
yp6 <- polyval(taylor(f, c, 6), x)
yp8 <- polyval(taylor(f, c, 8), x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp2, col = "#c8e6c9")
lines(x, yp4, col = "#81c784")
lines(x, yp6, col = "#4caf50")
lines(x, yp8, col = "#388e3c")
legend(
'topleft',
inset = .05,
legend = c("TS 8 terms", "TS 6 terms", "TS 4 terms", "TS 2 terms", "f(x)"),
col = c('#388e3c', '#4caf50', '#81c784', '#c8e6c9', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
f0 <- function(x) {
res = sin(x)
return(res)
}
f1 <- function(x) {
res = exp(complex(real = 0, imaginary = 1)*x)
return(res)
}
}
else{
}
######## Procedure for Problem 4 ############################################
if (problemId == "Second Section - Problem c)"){
}
else{
}
})
########### THIS SECTION IS FOR THE PLOTS CREATED BY THE PROGRAM ###############
output$`Graphical Representation` <- renderPlot({
problemId <- input$`ExamProblems`
############## Plot for Problem 1 ##############################################
if (problemId == "First Section - Problem 1 a)") {
choco_data = read.csv("Chocolate.csv")
chocolate_labels <- choco_data[,1]
choco_data <- choco_data[,-1]
choco_data$chocolate <- as.factor(choco_data$chocolate)
mdl <- glm(chocolate ~ ., data = choco_data, family = "binomial")
mdl <- glm(chocolate ~ fruity + winpercent, data = choco_data, family = "binomial")
predicted <- predict(mdl, choco_data[,], type = "response")
glm_predicted = ifelse(predicted > 0.5, 1, 0)
graph <- hist(glm_predicted, main = "Histogram of Chocolate Frequency in Candy", ylab = "Frequency of Trait", xlab = "Presence of Chocolate", ylim = c(0, 60), labels = TRUE)
}
else{
############## Plot for Problem 2 ##############################################
if (problemId == "Second Section - Problem a)") {
}
else{
############## Plot for problem 3 ##############################################
if (problemId == "Second Section - Problem b)") {
}
else{
############## Plot for problem 4 ##############################################
if (problemId == "Second Section - Problem c)") {
}
else{
graph <- "Sorry for the inconvenience, we are still working hard to make this application evenn better."
}
}
}
}
paste(graph)
})
########### THIS SECTION CORRESPONDS ONLY TO THE CHOCOLATE DATA ################
output$`Chocolate` <- renderTable({
choco_data = read.csv("Chocolate.csv")
choco_data
})
}
shinyApp(ui = ui, server = server)
runApp()
runApp()
runApp()
runApp()
runApp()
?checkboxInput()
runApp()
?numericInput()
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
# Chunk 2: eruptions
inputPanel(
selectInput("n_breaks", label = "Number of bins:",
choices = c(10, 20, 35, 50), selected = 20),
sliderInput("bw_adjust", label = "Bandwidth adjustment:",
min = 0.2, max = 2, value = 1, step = 0.2)
)
renderPlot({
hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
xlab = "Duration (minutes)", main = "Geyser eruption duration")
dens <- density(faithful$eruptions, adjust = input$bw_adjust)
lines(dens, col = "blue")
})
# Chunk 3: tabsets
shinyAppDir(
system.file("examples/06_tabsets", package = "shiny"),
options = list(
width = "100%", height = 550
)
)
runApp()
runApp()
runApp()
runApp()
?numericInput
runApp()
runApp()
runApp()
?renderPrint
runApp()
runApp()
runApp()
?echo
# Decided to develop an App in order to make the MidTerm exam more user Freindly.
# Install the shiny package:
# install.packages("shiny")
# Load Library:
# library(shiny)
# Giving some style:
# install.packages("shinythemes")
# Load Library:
# library(shinythemes)
# Adding the codes:
library(markdown)
runApp()
?renderUI
runApp()
?polyval()
?as.function
c("348",4)
sin(3)
class(sin(3))
class(sin(x))
x = 2
class(sin(x))
combine_words(c("a", "b"))
x<-as.character(c("A","B","C","D","E","F"))
y<-as.factor(c("1","2","3","4","5","6"))
?paste
paste(x,y, sep="")
colo <- as.character("#c8e6c")
y <- as.factor(2)
paste(x,y)
paste(colo,y)
paste(colo,y, sep = "")
library(pracma)
taylorPlot <- function(f, c, from, to) {
# Plot the Taylor approximations up to the 2nd, 4th, 6th and 8th terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# c : numeric
# point where the series expansion will take place
# from, to : numeric
# Interval of points to be ploted
#
# Returns
# -------
# void
x <- seq(from, to, length.out = 100)
yf <- f(x)
yp2 <- polyval(taylor(f, c, 2), x)
yp4 <- polyval(taylor(f, c, 4), x)
yp6 <- polyval(taylor(f, c, 6), x)
yp8 <- polyval(taylor(f, c, 8), x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp2, col = "#c8e6c9")
lines(x, yp4, col = "#81c784")
lines(x, yp6, col = "#4caf50")
lines(x, yp8, col = "#388e3c")
legend(
'topleft',
inset = .05,
legend = c("TS 8 terms", "TS 6 terms", "TS 4 terms", "TS 2 terms", "f(x)"),
col = c('#388e3c', '#4caf50', '#81c784', '#c8e6c9', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
f0 <- function(x) {
res = sin(x)
return(res)
}
f1 <- function(x) {
res = exp(complex(real = 0, imaginary = 1)*x)
return(res)
}
taylorPlot(f0, 0, -6.6, 6.6)
taylorPlot(f1, 1, -2*pi, 2*pi)
?legend()
runApp()
?taylorPlot()
?function()
function
function¡+`dasf´zcvnmz  `
?function
polyval()
?polyval
?taylor
runApp()
runApp()
as.factor("1 2 3 4")
as.array("1 2 3 4")
as.list("1 2 3 4")
as.vector("1 2 3 4")
runApp()
runApp()
