col = "black",
lwd = 2
)
lines(x2, y2, col = "#f44336")
lines(x3, y3, col = "#4caf50")
lines(x4, y4, col = "#2196f3")
legend(
'topleft',
inset = .05,
legend = c("RK 4th order", "RK 3rd order", "RK 2nd order", "f'(x)"),
col = c('#2196f3', '#4caf50', '#f44336', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
funct           = "2*x^3 + y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x + 4*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x + 2*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "2*x + y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x + y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 + y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^3 + y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^5 + y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 + y^2"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x + y^2"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 + y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 - y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 - y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x - y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x - 2*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "-x^2 + y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 - 0.5*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 - 0.125*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 - 0.01*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 - 0.02*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
funct           = "x^2 - 0.05*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
library(polynom)
library(pracma)
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[,1]
y = coordinates[,2]
interPoly = poly.calc(x,y)
xx = x
yy = lagrangeInterp(x,y,xx)
plot(xx, yy, xlab="x", ylab="f(x)")
lines(interPoly, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly)
}
x = seq(-5,5,0.5)
y = x^3 + 5*x^2 + 1
lagrange(cbind(x,y))
library(polynom)
library(pracma)
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[,1]
y = coordinates[,2]
interPoly = poly.calc(x,y)
xx = x
yy = lagrangeInterp(x,y,xx)
plot(xx, yy, xlab="x", ylab="f(x)", main = ' Lagrange polynomials ')
lines(interPoly, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly)
}
x = seq(-5,5,0.5)
y = x^3 + 5*x^2 + 1
lagrange(cbind(x,y))
library(pracma)
taylorPlot <- function(funct, taylorOrder) {
# Plot the Taylor approximations up to the taylorOrder terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# taylorOrder : numeric
# the number of terms to get
#
# Returns
# -------
# The Taylor Series
f <- function(n) {
return(eval(parse(text=funct), envir=list(x=n)))
}
# Interval of points to be ploted
from = -2*pi
to = 2*pi
x <- seq(from, to, length.out = 100)
yf <- f(x)
c <- 0 # The Taylor Series shall be centered in zero
taylorOut <- taylor(f, c, taylorOrder)
yp <- polyval(taylorOut, x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Taylor Approximation", "f(x)"),
col = c('#4caf50', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(taylorOut)
}
taylorPlot("sin(x)", 5)
taylorPlot("cos(x)", 2)
taylorPlot("tan(x)", 3)
# Runge-Kutta - 2nd order
rungeKutta2 <- function(funct, x0, y0, x1, n) {
f <- function(xx,yy) {
return(eval(parse(text=funct), envir=list(x=xx,y=yy)))
}
vx <- double(n + 1)
vy <- double(n + 1)
vx[1] <- x <- x0
vy[1] <- y <- y0
h <- (x1 - x0)/n
for(i in 1:n) {
k1 <- h*f(x, y)
k2 <- h*f(x + 0.5*h, y + 0.5*k1)
vx[i + 1] <- x <- x0 + i*h
vy[i + 1] <- y <- y + (k1 + k2)/2
}
return(cbind(vx, vy))
}
# Runge-Kutta - 3rd order
rungeKutta3 <- function(funct, x0, y0, x1, n) {
f <- function(xx,yy) {
return(eval(parse(text=funct), envir=list(x=xx,y=yy)))
}
vx <- double(n + 1)
vy <- double(n + 1)
vx[1] <- x <- x0
vy[1] <- y <- y0
h <- (x1 - x0)/n
for(i in 1:n) {
k1 <- h*f(x, y)
k2 <- h*f(x + 0.5*h, y + 0.5*k1)
k3 <- h*f(x + 0.5*h, y + 0.5*k2)
vx[i + 1] <- x <- x0 + i*h
vy[i + 1] <- y <- y + (k1 + 4*k2 + k3)/6
}
return(cbind(vx, vy))
}
# Runge-Kutta - 4th order
rungeKutta4 <- function(funct, x0, y0, x1, n) {
f <- function(xx,yy) {
return(eval(parse(text=funct), envir=list(x=xx,y=yy)))
}
vx <- double(n + 1)
vy <- double(n + 1)
vx[1] <- x <- x0
vy[1] <- y <- y0
h <- (x1 - x0)/n
for(i in 1:n) {
k1 <- h*f(x, y)
k2 <- h*f(x + 0.5*h, y + 0.5*k1)
k3 <- h*f(x + 0.5*h, y + 0.5*k2)
k4 <- h*f(x + h, y + k3)
vx[i + 1] <- x <- x0 + i*h
vy[i + 1] <- y <- y + (k1 + 2*k2 + 2*k3 + k4)/6
}
return(cbind(vx, vy))
}
RKPlot <- function(func, x0, y0, x1, n) {
# Plot of the second, third and fourth order RK approximations
#
# Parameters
# ----------
# func : string
# function of two variable
# x0, y0 : numeric
# initial values
# x1 : numeric
# upper bound
# n : numeric
# number of steps
#
# Returns
# -------
# void
# Calculate aproxminations
rk2 = rungeKutta2(func, x0, y0, x1, n)
rk3 = rungeKutta3(func, x0, y0, x1, n)
rk4 = rungeKutta4(func, x0, y0, x1, n)
x2 <- rk2[,1]
y2 <- rk2[,2]
x3 <- rk3[,1]
y3 <- rk3[,2]
x4 <- rk4[,1]
y4 <- rk4[,2]
# Computeanalytical answer of the ODE to compare all the approximations
model <- function(x, y, parms){
with(as.list(c(y,parms)), {
dy = eval(parse(text=funct), envir=list(x,y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <- seq(init_x,upper_bound,length(init_x:upper_bound)/number_of_steps)
out <- ode( y, times = x, model, parms )
# Plot
plot(
out,
xlab = "x",
ylab = "f'(x)",
type = "l",
main = ' Runge-Kutta ',
col = "black",
lwd = 2
)
lines(x2, y2, col = "#f44336")
lines(x3, y3, col = "#4caf50")
lines(x4, y4, col = "#2196f3")
legend(
'topleft',
inset = .05,
legend = c("RK 4th order", "RK 3rd order", "RK 2nd order", "f'(x)"),
col = c('#2196f3', '#4caf50', '#f44336', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
funct           = "x^2 - 0.05*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
# Runge-Kutta - 2nd order
rungeKutta2 <- function(funct, x0, y0, x1, n) {
f <- function(xx,yy) {
return(eval(parse(text=funct), envir=list(x=xx,y=yy)))
}
vx <- double(n + 1)
vy <- double(n + 1)
vx[1] <- x <- x0
vy[1] <- y <- y0
h <- (x1 - x0)/n
for(i in 1:n) {
k1 <- h*f(x, y)
k2 <- h*f(x + 0.5*h, y + 0.5*k1)
vx[i + 1] <- x <- x0 + i*h
vy[i + 1] <- y <- y + (k1 + k2)/2
}
return(cbind(vx, vy))
}
# Runge-Kutta - 3rd order
rungeKutta3 <- function(funct, x0, y0, x1, n) {
f <- function(xx,yy) {
return(eval(parse(text=funct), envir=list(x=xx,y=yy)))
}
vx <- double(n + 1)
vy <- double(n + 1)
vx[1] <- x <- x0
vy[1] <- y <- y0
h <- (x1 - x0)/n
for(i in 1:n) {
k1 <- h*f(x, y)
k2 <- h*f(x + 0.5*h, y + 0.5*k1)
k3 <- h*f(x + 0.5*h, y + 0.5*k2)
vx[i + 1] <- x <- x0 + i*h
vy[i + 1] <- y <- y + (k1 + 4*k2 + k3)/6
}
return(cbind(vx, vy))
}
# Runge-Kutta - 4th order
rungeKutta4 <- function(funct, x0, y0, x1, n) {
f <- function(xx,yy) {
return(eval(parse(text=funct), envir=list(x=xx,y=yy)))
}
vx <- double(n + 1)
vy <- double(n + 1)
vx[1] <- x <- x0
vy[1] <- y <- y0
h <- (x1 - x0)/n
for(i in 1:n) {
k1 <- h*f(x, y)
k2 <- h*f(x + 0.5*h, y + 0.5*k1)
k3 <- h*f(x + 0.5*h, y + 0.5*k2)
k4 <- h*f(x + h, y + k3)
vx[i + 1] <- x <- x0 + i*h
vy[i + 1] <- y <- y + (k1 + 2*k2 + 2*k3 + k4)/6
}
return(cbind(vx, vy))
}
RKPlot <- function(func, x0, y0, x1, n) {
# Plot of the second, third and fourth order RK approximations
#
# Parameters
# ----------
# func : string
# function of two variable
# x0, y0 : numeric
# initial values
# x1 : numeric
# upper bound
# n : numeric
# number of steps
#
# Returns
# -------
# void
# Calculate aproxminations
rk2 = rungeKutta2(func, x0, y0, x1, n)
rk3 = rungeKutta3(func, x0, y0, x1, n)
rk4 = rungeKutta4(func, x0, y0, x1, n)
x2 <- rk2[,1]
y2 <- rk2[,2]
x3 <- rk3[,1]
y3 <- rk3[,2]
x4 <- rk4[,1]
y4 <- rk4[,2]
# Computeanalytical answer of the ODE to compare all the approximations
model <- function(x, y, parms){
with(as.list(c(y,parms)), {
dy = eval(parse(text=funct), envir=list(x,y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <- seq(init_x,upper_bound,length(init_x:upper_bound)/number_of_steps)
out <- ode( y, times = x, model, parms )
# Plot
plot(
out,
xlab = "x",
ylab = "f'(x)",
type = "l",
main = ' Runge-Kutta ',
col = "black",
lwd = 2
)
lines(x2, y2, col = "#f44336")
lines(x3, y3, col = "#4caf50")
lines(x4, y4, col = "#2196f3")
legend(
'topleft',
inset = .05,
legend = c("RK 4th order", "RK 3rd order", "RK 2nd order", "f'(x)"),
col = c('#2196f3', '#4caf50', '#f44336', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
funct           = "x^2 - 0.05*y"
init_y          = 1
init_x          = -10
upper_bound     = 10
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
