# initial values
# x1 : numeric
# upper bound
# n : numeric
# number of steps
#
# Returns
# -------
# void
# Calculate aproxminations
rk2 = rungeKutta2(func, x0, y0, x1, n)
rk3 = rungeKutta3(func, x0, y0, x1, n)
rk4 = rungeKutta4(func, x0, y0, x1, n)
x2 <- rk2[,1]
y2 <- rk2[,2]
x3 <- rk3[,1]
y3 <- rk3[,2]
x4 <- rk4[,1]
y4 <- rk4[,2]
# Compute analytical answer of the ODE to compare all the approximations
model <- function(x, y, parms){
with(as.list(c(y,parms)), {
dy = eval(parse(text=funct), envir=list(x,y))#2*x^3 + y
list(dy)
})
}
y <- c(y = init_y)
parms <- c()
x <- seq(init_x,upper_bound,length(init_x:upper_bound)/number_of_steps)
out <- ode( y, times = x, model, parms )
# Plot
plot(
out,
xlab = "x",
ylab = "f'(x)",
type = "l",
main = ' Runge-Kutta ',
col = "black",
lwd = 2
)
lines(x2, y2, col = "#f44336")
lines(x3, y3, col = "#4caf50")
lines(x4, y4, col = "#2196f3")
legend(
'topleft',
inset = .05,
legend = c("RK 4th order", "RK 3rd order", "RK 2nd order", "deSolve ode function"),
col = c('#2196f3', '#4caf50', '#f44336', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
}
funct           = "x^2 - y"
init_y          = 1
init_x          = -5
upper_bound     = 5
number_of_steps = length(init_x:upper_bound)*2
RKPlot(funct, init_x, init_y, upper_bound, number_of_steps)
rm(list = ls(all = TRUE)) # Delete workspace
graphics.off() # Clear plots
cat("\014") # Clear console
getpoly <- function(coef = c(0, 1)) {
a <- as.numeric(coef)
while ((la <- length(a)) > 1 && a[la] == 0)
a <- a[-la]
structure(a, class = "polynomial")
}
poly2char <- function(x, decreasing = FALSE, ...)
{
p <- unclass(x)
lp <- length(p) - 1
names(p) <- 0:lp
p <- p[p != 0]
if (length(p) == 0)
return("0")
if (decreasing)
p <- rev(p)
signs <- ifelse(p < 0, "- ", "+ ")
signs[1] <- if (signs[1] == "- ")
"-"
else
""
np <- names(p)
p <- as.character(abs(p))
p[p == "1" & np != "0"] <- ""
pow <- paste("x^", np, sep = "")
pow[np == "0"] <- ""
pow[np == "1"] <- "x"
stars <- rep.int("*", length(p))
stars[p == "" | pow == ""] <- ""
paste(signs, p, stars, pow, sep = "", collapse = " ")
}
interpolatepoly <- function(x, y, tol = sqrt(.Machine$double.eps)) {
if (missing(y)) {
p <- 1
for (xi in x)
p <- c(0, p) - c(xi * p, 0)
return(getpoly(p))
}
toss <- duplicated(x)
if (any(toss)) {
crit <- max(tapply(y, x, function(x)
diff(range(x))))
keep <- !toss
y <- y[keep]
x <- x[keep]
}
m <- length(x)
if (m <= 1)
return(getpoly(y))
r <- 0
for (i in 1:m)
r <- r + (y[i] * unclass(Recall(x[-i]))) / prod(x[i] - x[-i])
r[abs(r) < tol] <- 0
getpoly(r)
}
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[, 1]
y = coordinates[, 2]
interPoly = interpolatepoly(x, y)
interPoly_str = poly2char(interPoly)
interpolation <- function(n) {
return(eval(parse(text = interPoly_str), envir = list(x = n)))
}
yy = c()
for (i in 1:length(x)) {
yy[i] = interpolation(x[i])
}
plot(x,
y,
xlab = "x",
ylab = "f(x)",
main = ' Lagrange polynomials ')
lines(x, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly_str)
}
x = seq(-5, 5, 0.5)
y = x ^ 3 + 5 * x ^ 2 + 1
lagrange(cbind(x, y))
x = seq(-5, 5, 0.5)
y = x ^ 4 + 5 * x ^ 2 + 1
lagrange(cbind(x, y))
y = x ^ 6 + 5 * x ^ 2 + 1
lagrange(cbind(x, y))
for (i in 1:length(xx)) {
yy[i] = interpolation(xx[i])
}
plot(x,
y,
xlab = "x",
ylab = "f(x)",
main = ' Lagrange polynomials ')
lines(x, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[, 1]
y = coordinates[, 2]
interPoly = interpolatepoly(x, y)
interPoly_str = poly2char(interPoly)
interpolation <- function(n) {
return(eval(parse(text = interPoly_str), envir = list(x = n)))
}
xx = seq(min(x), max(x), length(x)/3)
yy = c()
for (i in 1:length(xx)) {
yy[i] = interpolation(xx[i])
}
plot(x,
y,
xlab = "x",
ylab = "f(x)",
main = ' Lagrange polynomials ')
lines(x, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly_str)
}
x = seq(-5, 5, 0.5)
y = x ^ 6 + 5 * x ^ 2 + 1
lagrange(cbind(x, y))
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[, 1]
y = coordinates[, 2]
interPoly = interpolatepoly(x, y)
interPoly_str = poly2char(interPoly)
interpolation <- function(n) {
return(eval(parse(text = interPoly_str), envir = list(x = n)))
}
xx = seq(min(x), max(x), length(x)/1000)
yy = c()
for (i in 1:length(xx)) {
yy[i] = interpolation(xx[i])
}
plot(x,
y,
xlab = "x",
ylab = "f(x)",
main = ' Lagrange polynomials ')
lines(x, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly_str)
}
x = seq(-5, 5, 0.5)
y = x ^ 6 + 5 * x ^ 2 + 1
lagrange(cbind(x, y))
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[, 1]
y = coordinates[, 2]
interPoly = interpolatepoly(x, y)
interPoly_str = poly2char(interPoly)
interpolation <- function(n) {
return(eval(parse(text = interPoly_str), envir = list(x = n)))
}
xx = seq(min(x), max(x), length(x)/1000)
yy = c()
for (i in 1:length(xx)) {
yy[i] = interpolation(xx[i])
}
plot(x,
y,
xlab = "x",
ylab = "f(x)",
main = ' Lagrange polynomials ')
lines(xx, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly_str)
}
x = seq(-5, 5, 0.5)
y = x ^ 6 + 5 * x ^ 2 + 1
lagrange(cbind(x, y))
x = seq(-5, 5, 0.5)
y = x ^ 2 + 5 * x ^ 2 + 1
lagrange(cbind(x, y))
x = seq(-5, 5, 0.5)
y = x ^ 5 + 5 * x ^ 2 + 1
lagrange(cbind(x, y))
x = seq(-5, 5, 0.5)
y = x ^ 5 + 5 * x ^ 2 + 8
lagrange(cbind(x, y))
x = seq(-5, 5, 0.5)
y = x ^ 1 + 5 * x ^ 2 + 8
lagrange(cbind(x, y))
x = seq(-5, 5, 0.5)
y = x ^ 2 + 5 * x ^ 2 + 8
lagrange(cbind(x, y))
x = seq(-5, 5, 0.5)
y = x ^ 2 + 5 * x ^ 4 + 8
lagrange(cbind(x, y))
x = seq(-5, 5, 0.5)
y = x ^ 2 + 5 * x ^ 3 + 8
lagrange(cbind(x, y))
?unclass
?names
library(shiny)
?double
double(3+5)
double(2)
vx <- double(n + 1)
vx <- double(5)
vx[1]
rm(list = ls(all = TRUE)) # Delete workspace
graphics.off() # Clear plots
cat("\014") # Clear console
# First we define a variable to call for the database to be analized:
choco_data = read.csv("Chocolate.csv")
str(choco_data) # Verifying there is no repeated information.
summary(choco_data) # Exploring the data.
chocolate_labels <-
choco_data[, 1] # First column contains the names of candy and we define it as the label for each row.
choco_data <-
choco_data[,-1] # Taking away the first column that contains the candy names.
# Setting numeric values to categoric value:
choco_data$chocolate <- as.factor(choco_data$chocolate)
summary(choco_data)
# Since the dependent variable "Chocolate" is a categorical variable, we have decided to use Logistic Regression:
mdl <- glm(chocolate ~ ., data = choco_data, family = "binomial")
summary(mdl)
mdl <-
glm(
chocolate ~ fruity + caramel +  peanutyalmondy + nougat + crispedricewafer + hard + bar + pluribus + sugarpercent + pricepercent + winpercent,
data = choco_data,
family = "binomial"
)
summary(mdl) # Visualizing the model to determine the most significant variables.
mdl <-
glm(chocolate ~ fruity + winpercent,
data = choco_data,
family = "binomial")
summary(mdl) # Visualizing the model to determine the most significant variables.
# Lets see the performance of our beta coefficients:
predicted <- predict(mdl, choco_data[,], type = "response")
hist(predicted)
#We assume that: all values less than 0.5 correspond to the first category, 0.5 or bigger correspond to the second category
glm_predicted = ifelse(predicted > 0.5, 1, 0)
hist(glm_predicted)
rm(list = ls(all = TRUE)) # Delete workspace
graphics.off() # Clear plots
cat("\014") # Clear console
# Enter the two column vectors for x and y values:
# *Remember to add the same amount of values on each vector!
x = seq(-5, 5, 0.5)
y = x ^ 2 + 5 * x ^ 3 + 8
# function to convert a list to a R polynomial
getpoly <- function(coef = c(0, 1)) {
a <- as.numeric(coef)
while ((la <- length(a)) > 1 && a[la] == 0)
a <- a[-la]
structure(a, class = "polynomial")
}
# function to convert a R polynomial to a string of characters
poly2char <- function(x, ...)
{
p <- unclass(x)
lp <- length(p) - 1
names(p) <- 0:lp
p <- p[p != 0]
# return zero if the polynomial is empty
if (length(p) == 0)
return("0")
# let's handle the signs (print nothing if positive)
signs <- ifelse(p < 0, "- ", "+ ")
signs[1] <- if (signs[1] == "- ")
"-"
else
""
# get the polynomial coeficient
np <- names(p)
p <- as.character(abs(p))
# get "empty" if the coeficient is zero
p[p == "1" & np != "0"] <- ""
# let's handle/get the exponent
pow <- paste("x^", np, sep = "")
pow[np == "0"] <- ""
pow[np == "1"] <- "x"
# add starts to show the multiplication between coefs and x's
stars <- rep.int("*", length(p))
stars[p == "" | pow == ""] <- ""
# use paste to concatenate the precious calculations
# and return the string
paste(signs, p, stars, pow, sep = "", collapse = " ")
}
interpolatepoly <- function(x, y, tol = sqrt(.Machine$double.eps)) {
# if y is not specified as an argument, then return something in the form of:
# y = x
if (missing(y)) {
p <- 1
for (xi in x)
p <- c(0, p) - c(xi * p, 0)
# abd get the polynomial
return(getpoly(p))
}
# let's check if some duplicates exist in x
jettison <- duplicated(x)
# if a least one value in jettison is true, then remove them
if (any(jettison)) {
# and merge the duplicates using recursion
crit <- max(tapply(y, x, function(x) diff(range(x))))
keep <- !jettison
# let's save the calculation for further use
y <- y[keep]
x <- x[keep]
}
# convert the list of coefs into a class polynomial if the list is
# short enough
m <- length(x)
if (m <= 1)
return(getpoly(y))
# Lagrange Interpolating Polynomial Formula
r <- 0
for (i in 1:m)
# from http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html
r <- r + (y[i] * unclass(Recall(x[-i]))) / prod(x[i] - x[-i])
r[abs(r) < tol] <- 0
getpoly(r)
}
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[, 1]
y = coordinates[, 2]
interPoly = interpolatepoly(x, y)
interPoly_str = poly2char(interPoly)
interpolation <- function(n) {
return(eval(parse(text = interPoly_str), envir = list(x = n)))
}
xx = seq(min(x), max(x), length(x) / 1000)
yy = c()
for (i in 1:length(xx)) {
yy[i] = interpolation(xx[i])
}
plot(x,
y,
xlab = "x",
ylab = "f(x)",
main = ' Lagrange polynomials ')
lines(xx, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly_str)
}
lagrange(cbind(x, y))
# Enter the two column vectors for x and y values:
# *Remember to add the same amount of values on each vector!
x = c(2,5,7,9,9.5)
y = c(3,5,1,9,10)
lagrange(cbind(x, y))
