type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Taylor Approximation", "f(x)"),
col = c('#4caf50', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(taylorOut)
}
taylorPlot("sin(x)", 8)
taylorPlot("cos(x)", 2)
taylorPlot("tan(x)", 3)
taylorPlot("sin(x)", 8)
taylorPlot("cos(x)", 2)
taylorPlot("tan(x)", 3)
cat("\014") # Clear console
rm(list = ls(all = TRUE)) # Delete workspace
mytaylor <- function(f, c, taylorOrder = 4) {
fun <- match.fun(f)
f <- function(x) fun(x)
T <- f(c)
for (i in 1:taylorOrder) {
T <- polyadd(T, fderiv(f, c, i)/fact(i) * polypow(c(1, -c), i))
}
return(T)
}
taylorPlot <- function(funct, taylorOrder) {
# Plot the Taylor approximations up to the taylorOrder terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# taylorOrder : numeric
# the number of terms to get
#
# Returns
# -------
# The Taylor Series
f <- function(n) {
return(eval(parse(text=funct), envir=list(x=n)))
}
# Interval of points to be ploted
from = -2*pi
to = 2*pi
x <- seq(from, to, length.out = 100)
yf <- f(x)
c <- 0 # The Taylor Series shall be centered in zero
taylorOut <- mytaylor(f, c, taylorOrder)
yp <- polyval(taylorOut, x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Taylor Approximation", "f(x)"),
col = c('#4caf50', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(taylorOut)
}
taylorPlot("sin(x)", 8)
cat("\014") # Clear console
rm(list = ls(all = TRUE)) # Delete workspace
mytaylor <- function(f, c, taylorOrder = 4) {
fun <- match.fun(f)
f <- function(x) fun(x)
T <- f(c)
library(pracma)
for (i in 1:taylorOrder) {
T <- polyadd(T, fderiv(f, c, i)/fact(i) * polypow(c(1, -c), i))
}
return(T)
}
taylorPlot <- function(funct, taylorOrder) {
# Plot the Taylor approximations up to the taylorOrder terms
#
# Parameters
# ----------
# f : function
# Vectorized function of one variable
# taylorOrder : numeric
# the number of terms to get
#
# Returns
# -------
# The Taylor Series
f <- function(n) {
return(eval(parse(text=funct), envir=list(x=n)))
}
# Interval of points to be ploted
from = -2*pi
to = 2*pi
x <- seq(from, to, length.out = 100)
yf <- f(x)
c <- 0 # The Taylor Series shall be centered in zero
taylorOut <- mytaylor(f, c, taylorOrder)
yp <- polyval(taylorOut, x)
plot(
x,
yf,
xlab = "x",
ylab = "f(x)",
type = "l",
main = ' Taylor Series Approximation of f(x) ',
col = "black",
lwd = 2
)
lines(x, yp, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Taylor Approximation", "f(x)"),
col = c('#4caf50', 'black'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(taylorOut)
}
taylorPlot("sin(x)", 8)
taylorPlot("cos(x)", 2)
taylorPlot("tan(x)", 3)
cat("\014") # Clear console
rm(list = ls(all = TRUE)) # Delete workspace
getpoly <- function(coef = c(0, 1)) {
a <- as.numeric(coef)
while((la <- length(a)) > 1 && a[la] == 0) a <- a[-la]
structure(a, class = "polynomial")
}
poly2char <- function(x, decreasing = FALSE, ...)
{
p <- unclass(x)
lp <- length(p) - 1
names(p) <- 0:lp
p <- p[p != 0]
if(length(p) == 0) return("0")
if(decreasing) p <- rev(p)
signs <- ifelse(p < 0, "- ", "+ ")
signs[1] <- if(signs[1] == "- ") "-" else ""
np <- names(p)
p <- as.character(abs(p))
p[p == "1" & np != "0"] <- ""
pow <- paste("x^", np, sep = "")
pow[np == "0"] <- ""
pow[np == "1"] <- "x"
stars <- rep.int("*", length(p))
stars[p == "" | pow == ""] <- ""
paste(signs, p, stars, pow, sep = "", collapse = " ")
}
interpolatepoly <- function(x, y, tol = sqrt(.Machine$double.eps), lab = dimnames(y)[[2]]) {
if(missing(y)) {
p <- 1
for(xi in x)
p <- c(0, p) - c(xi * p, 0)
return(getpoly(p))
}
if(is.matrix(y)) {
if(length(x) != nrow(y))
stop("x and y are inconsistent in size")
lis <- list()
if(is.null(lab))
lab <- paste("p", 1:(dim(y)[2]), sep = "")
for(i in 1:dim(y)[2])
lis[[lab[i]]] <- Recall(x, y[, i], tol)
return(structure(lis, class = "polylist"))
}
if(any(toss <- duplicated(x))) {
crit <- max(tapply(y, x, function(x) diff(range(x))))
if(crit > tol)
warning("some duplicated x-points have inconsistent y-values")
keep <- !toss
y <- y[keep]
x <- x[keep]
}
if((m <- length(x)) != length(y))
stop("x and y(x) do not match in length!")
if(m <= 1)
return(getpoly(y))
r <- 0
for(i in 1:m)
r <- r + (y[i] * unclass(Recall(x[ - i])))/prod(x[i] - x[ - i])
r[abs(r) < tol] <- 0
getpoly(r)
}
#library(pracma)
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[,1]
y = coordinates[,2]
interPoly = interpolatepoly(x,y)
interPoly_str = poly2char(interPoly)
interpolation <- function(n) {
return(eval(parse(text=interPoly_str), envir=list(x=n)))
}
yy = c()
for(i in 1:length(x)){
yy[i] = interpolation(x[i])
}
plot(x, y, xlab="x", ylab="f(x)", main = ' Lagrange polynomials ')
lines(x, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly_str)
}
x = seq(-5,5,0.5)
y = x^3 + 5*x^2 + 1
lagrange(cbind(x,y))
cat("\014") # Clear console
rm(list = ls(all = TRUE)) # Delete workspace
getpoly <- function(coef = c(0, 1)) {
a <- as.numeric(coef)
while((la <- length(a)) > 1 && a[la] == 0) a <- a[-la]
structure(a, class = "polynomial")
}
poly2char <- function(x, ...)
{
p <- unclass(x)
lp <- length(p) - 1
names(p) <- 0:lp
p <- p[p != 0]
if(length(p) == 0) return("0")
signs <- ifelse(p < 0, "- ", "+ ")
signs[1] <- if(signs[1] == "- ") "-" else ""
np <- names(p)
p <- as.character(abs(p))
p[p == "1" & np != "0"] <- ""
pow <- paste("x^", np, sep = "")
pow[np == "0"] <- ""
pow[np == "1"] <- "x"
stars <- rep.int("*", length(p))
stars[p == "" | pow == ""] <- ""
paste(signs, p, stars, pow, sep = "", collapse = " ")
}
interpolatepoly <- function(x, y, tol = sqrt(.Machine$double.eps), lab = dimnames(y)[[2]]) {
if(missing(y)) {
p <- 1
for(xi in x)
p <- c(0, p) - c(xi * p, 0)
return(getpoly(p))
}
if(is.matrix(y)) {
lis <- list()
if(is.null(lab))
lab <- paste("p", 1:(dim(y)[2]), sep = "")
for(i in 1:dim(y)[2])
lis[[lab[i]]] <- Recall(x, y[, i], tol)
return(structure(lis, class = "polylist"))
}
if(any(toss <- duplicated(x))) {
crit <- max(tapply(y, x, function(x) diff(range(x))))
keep <- !toss
y <- y[keep]
x <- x[keep]
}
if(m <= 1)
return(getpoly(y))
r <- 0
for(i in 1:m)
r <- r + (y[i] * unclass(Recall(x[ - i])))/prod(x[i] - x[ - i])
r[abs(r) < tol] <- 0
getpoly(r)
}
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[,1]
y = coordinates[,2]
interPoly = interpolatepoly(x,y)
interPoly_str = poly2char(interPoly)
interpolation <- function(n) {
return(eval(parse(text=interPoly_str), envir=list(x=n)))
}
yy = c()
for(i in 1:length(x)){
yy[i] = interpolation(x[i])
}
plot(x, y, xlab="x", ylab="f(x)", main = ' Lagrange polynomials ')
lines(x, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly_str)
}
x = seq(-5,5,0.5)
y = x^3 + 5*x^2 + 1
lagrange(cbind(x,y))
cat("\014") # Clear console
rm(list = ls(all = TRUE)) # Delete workspace
getpoly <- function(coef = c(0, 1)) {
a <- as.numeric(coef)
while((la <- length(a)) > 1 && a[la] == 0) a <- a[-la]
structure(a, class = "polynomial")
}
poly2char <- function(x, decreasing = FALSE, ...)
{
p <- unclass(x)
lp <- length(p) - 1
names(p) <- 0:lp
p <- p[p != 0]
if(length(p) == 0) return("0")
if(decreasing) p <- rev(p)
signs <- ifelse(p < 0, "- ", "+ ")
signs[1] <- if(signs[1] == "- ") "-" else ""
np <- names(p)
p <- as.character(abs(p))
p[p == "1" & np != "0"] <- ""
pow <- paste("x^", np, sep = "")
pow[np == "0"] <- ""
pow[np == "1"] <- "x"
stars <- rep.int("*", length(p))
stars[p == "" | pow == ""] <- ""
paste(signs, p, stars, pow, sep = "", collapse = " ")
}
interpolatepoly <- function(x, y, tol = sqrt(.Machine$double.eps), lab = dimnames(y)[[2]]) {
if(missing(y)) {
p <- 1
for(xi in x)
p <- c(0, p) - c(xi * p, 0)
return(getpoly(p))
}
if(is.matrix(y)) {
if(length(x) != nrow(y))
stop("x and y are inconsistent in size")
lis <- list()
if(is.null(lab))
lab <- paste("p", 1:(dim(y)[2]), sep = "")
for(i in 1:dim(y)[2])
lis[[lab[i]]] <- Recall(x, y[, i], tol)
return(structure(lis, class = "polylist"))
}
if(any(toss <- duplicated(x))) {
crit <- max(tapply(y, x, function(x) diff(range(x))))
if(crit > tol)
warning("some duplicated x-points have inconsistent y-values")
keep <- !toss
y <- y[keep]
x <- x[keep]
}
if((m <- length(x)) != length(y))
stop("x and y(x) do not match in length!")
if(m <= 1)
return(getpoly(y))
r <- 0
for(i in 1:m)
r <- r + (y[i] * unclass(Recall(x[ - i])))/prod(x[i] - x[ - i])
r[abs(r) < tol] <- 0
getpoly(r)
}
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[,1]
y = coordinates[,2]
interPoly = interpolatepoly(x,y)
interPoly_str = poly2char(interPoly)
interpolation <- function(n) {
return(eval(parse(text=interPoly_str), envir=list(x=n)))
}
yy = c()
for(i in 1:length(x)){
yy[i] = interpolation(x[i])
}
plot(x, y, xlab="x", ylab="f(x)", main = ' Lagrange polynomials ')
lines(x, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly_str)
}
x = seq(-5,5,0.5)
y = x^3 + 5*x^2 + 1
lagrange(cbind(x,y))
interpolatepoly <- function(x, y, tol = sqrt(.Machine$double.eps), lab = dimnames(y)[[2]]) {
if(missing(y)) {
p <- 1
for(xi in x)
p <- c(0, p) - c(xi * p, 0)
return(getpoly(p))
}
if(is.matrix(y)) {
lis <- list()
if(is.null(lab))
lab <- paste("p", 1:(dim(y)[2]), sep = "")
for(i in 1:dim(y)[2])
lis[[lab[i]]] <- Recall(x, y[, i], tol)
return(structure(lis, class = "polylist"))
}
if(any(toss <- duplicated(x))) {
crit <- max(tapply(y, x, function(x) diff(range(x))))
keep <- !toss
y <- y[keep]
x <- x[keep]
}
m <- length(x)
if(m <= 1)
return(getpoly(y))
r <- 0
for(i in 1:m)
r <- r + (y[i] * unclass(Recall(x[ - i])))/prod(x[i] - x[ - i])
r[abs(r) < tol] <- 0
getpoly(r)
}
lagrange <- function(coordinates) {
# Plot the Lagrange polynomial, evaluated within the x coordinates
# (from parameter coordinates)
#
# Parameters
# ----------
# coordinates : nx2 matrix
# where the first column represents the x coordinate while the second
# column represents the y coordinate
#
# Returns
# -------
# The Lagrange polynomial
x = coordinates[,1]
y = coordinates[,2]
interPoly = interpolatepoly(x,y)
interPoly_str = poly2char(interPoly)
interpolation <- function(n) {
return(eval(parse(text=interPoly_str), envir=list(x=n)))
}
yy = c()
for(i in 1:length(x)){
yy[i] = interpolation(x[i])
}
plot(x, y, xlab="x", ylab="f(x)", main = ' Lagrange polynomials ')
lines(x, yy, col = "#4caf50")
legend(
'topleft',
inset = .05,
legend = c("Coordinates", "Lagrange polynomial"),
col = c('black', '#4caf50'),
lwd = c(1),
bty = 'n',
cex = .75
)
return(interPoly_str)
}
x = seq(-5,5,0.5)
y = x^3 + 5*x^2 + 1
lagrange(cbind(x,y))
