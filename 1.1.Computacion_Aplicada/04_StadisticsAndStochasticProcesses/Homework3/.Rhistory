)
)
View(mb3_predictions)
View(mb3_predictions)
View(mb3_predictions$z)
# You can also use the summary() function to obtain the most likely model and the most possible number of clusters.
summary(mb3)
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
mb = Mclust(mydata[,-5])
#or specify number of clusters
mb3 = Mclust(mydata[,-5], 3)
# optimal selected model
mb3$modelName
# optimal number of cluster
mb3$G
# probality for an observation to be in a given cluster
head(mb3$z)
# get probabilities, means, variances
summary(mb3, parameters = TRUE)
# Compare amount of the data within each cluster
table(iris$Species, mb$classification)
# vs
table(iris$Species, mb3$classification)
# After the data is fit into the model, we plot the model based on clustering results.
plot(mb3, "classification")
# Let's plot estimated density. Contour plot
plot(mb3, "density")
plot(mb3, "uncertainty")
# You can also use the summary() function to obtain the most likely model and the most possible number of clusters.
summary(mb3)
# predict cluster for the observed data
pred <- predict(mb3)
str(pred)
pred$z              # equal to mb3$z
pred$classification # equal to
plot(faithful, col = pred$classification, pch = pred$classification)
# predict cluster over a grid
grid <- apply(faithful, 2, function(x) seq(min(x), max(x), length = 50))
grid <- expand.grid(eruptions = grid[,1], waiting = grid[,2])
pred <- predict(mb3, grid)
# predict cluster over a grid
grid <- apply(iris, 2, function(x) seq(min(x), max(x), length = 50))
# predict cluster over a grid
grid <- apply(iris, 2, function(x) seq(min(x), max(x), length = 50))
# predict cluster for the observed data
pred <- predict(mb3)
str(pred)
pred$z              # equal to mb3$z
pred$classification # equal to
plot(mydata, col = pred$classification, pch = pred$classification)
# predict cluster over a grid
grid <- apply(mydata, 2, function(x) seq(min(x), max(x), length = 50))
grid <- expand.grid(eruptions = grid[,1], waiting = grid[,2])
pred <- predict(mb3, grid)
plot(grid, col = mclust.options("classPlotColors")[pred$classification], pch = 15, cex = 0.5)
points(mydata, pch = mb3$classification)
# predict cluster over a grid
grid <- apply(mydata, 2, function(x) seq(min(x), max(x), length = 50))
# predict cluster over a grid
grid <- apply(mydata, 2, function(x) seq(min(x), max(x), length = 50))
grid <- expand.grid(eruptions = grid[,1], waiting = grid[,2])
# predict cluster over a grid
grid <- apply(mydata, 5, function(x) seq(min(x), max(x), length = 50))
# predict cluster over a grid
grid <- apply(mydata, 2, function(x) seq(min(x), max(x), length = 50))
View(grid)
View(grid)
View(grid)
# predict cluster over a grid
#grid <- apply(mydata, 2, function(x) seq(min(x), max(x), length = 50))
grid <- expand.grid(eruptions = grid[,1], waiting = grid[,2])
pred <- predict(mb3, grid)
confusionMatrix(as.factor(pred$z), as.factor(mydata$Species), positive = NULL, dnn = c("Prediction", "Reference"))
mb3$parameters$z
mb3$parameters
plot(mb3, what = "density", data = acidity, breaks = 15)
plot(mb3, what = "density", data = mydata, breaks = 15)
plot(mb3, what = "density", breaks = 15)
plot(mb3, "diagnostic")
plot(3d4, what = "diagnostic", type = "cdf")
plot(md3, what = "diagnostic", type = "cdf")
plot(mb3, what = "diagnostic", type = "cdf")
plot(mb3, what = "density", type = "persp")
plot(mb3, what = "density", type = "level")
plot(mb3, what = "density", type = "level",
data = mydata, points.cex = 0.5)
plot(mb3, what = "density")
# predict cluster for the observed data
pred <- predict(mb3)
str(pred)
pred$z              # equal to mb3$z
pred$classification # equal to
plot(mydata, col = pred$classification, pch = pred$classification)
confusionMatrix(as.factor(pred$z), as.factor(mb3$parameters$z), positive = NULL, dnn = c("Prediction", "Reference"))
data(iris)
class <- iris$Species
table(class)
X <- iris[,1:4]
head(X)
mod2 <- MclustDA(X, class, modelType = "EDDA")
summary(mod2)
plot(mod2, what = "scatterplot")
plot(mod2, what = "classification")
cv <- cvMclustDA(mod2, nfold = 10)
str(cv)
unlist(cv[3:4])
cv <- cvMclustDA(mod3, nfold = 10)
str(cv)
unlist(cv[3:4])
plot(iris[, 1:4], col = iris$Species, pch = 18, main = "Fisher's Iris Dataset")
# Select 4 continuous variables and look for three distinct groups.
mcl.model <- Mclust(iris[, 1:4], 3)
# Plot our results.
plot(mcl.model, what = "classification", main = "Mclust Classification")
data(iris)
irisMatrix <- iris[,1:4]
irisClass <- iris[,5]
.Mclust
.Mclust <- mclustOptions(tol = 1.e-6, emModelNames = c("VII", "VVI", "VVV"))
.Mclust
irisBic <- EMclust(irisMatrix)
summary(irisBic, irisMatrix)
library(mclust);
.Mclust
irisBic <- EMclust(irisMatrix)
irisBic
ms <- mstep(modelName = "VVV", data = iris[,-5], z = unmap(iris[,5]))
names(ms)
es <- estep(modelName = "VVV", data = iris[,-5], parameters = ms$parameters)
names(es)
meVVViris <- me(modelName = "VVV", data = iris[,-5], z = unmap(iris[,5]))
uncer <- 1 - apply( meVVViris$z, 1, max)
quantile(uncer)
uncerPlot(z = meVVViris$z, truth = iris[,5])
clPairs(data = iris[,-5], classification = iris[,5])
hcVVViris <- hc(modelName = "VVV", data = iris[,-5])
cl <- hclass(hcVVViris, 2:3)
clPairs(data = iris[,-5], classification = cl[,"2"])
clPairs(data = iris[,-5], classification = cl[,"3"])
clPairs(data = iris[,-5], classification = cl[,"2"])
clPairs(data = iris[,-5], classification = cl[,"3"])
classError(cl[,"3"], truth = iris[,5])
MCLUST = Mclust(iris[,1:4])
MCLUST
DR = MclustDR(MCLUST)
summary(DR)
plot(DR, what = "evalues")
plot(DR)
MCLUST = Mclust(iris[,1:4], 3)
MCLUST
DR = MclustDR(MCLUST)
summary(DR)
plot(DR, what = "evalues")
plot(DR)
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
head(iris)
head(mydata)
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
head(mydata)
species_labels <- mydata[,5]
species_col <- c("#7DB0DD","#86B875","#E495A5")
pairs(mydata[,-5], col = species_col[species_labels],
lower.panel = NULL, cex.labels=2, pch=19, cex = 1)
par(xpd = TRUE)
legend(x = 0.1, y = 0.4, cex = 1.2,
legend(x = 0.1, y = 0.4, cex = 1.2,
legend = as.character(levels(species_labels)), fill = species_col)
species_labels <- mydata[,5]
species_labels <- mydata[,5]
species_col <- c("#7DB0DD","#86B875","#E495A5")
pairs(mydata[,-5], col = species_col[species_labels],
lower.panel = NULL, cex.labels=2, pch=19, cex = 1)
par(xpd = TRUE)
legend(x = 0.1, y = 0.4, cex = 1.2,
legend = as.character(levels(species_labels)), fill = species_col)
legend(x = 0.1, y = 0.4, cex = 1.2,
legend = as.character(levels(species_labels)), fill = species_col)
par(xpd = TRUE)
legend(x = 0.1, y = 0.4, cex = 1.2,
legend = as.character(levels(species_labels)), fill = species_col)
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
#cor(mydata);
head(mydata)
species_labels <- mydata[,5]
species_col <- c("#7DB0DD","#86B875","#E495A5")
pairs(mydata[,-5], col = species_col[species_labels],
lower.panel = NULL, cex.labels=2, pch=19, cex = 1)
par(xpd = TRUE)
legend(x = 0.1, y = 0.4, cex = 1.2,
legend = as.character(levels(species_labels)), fill = species_col)
legend(x = 0.1, y = 0.4, cex = 1.2)
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
#cor(mydata);
head(mydata)
species_labels <- mydata[,5]
species_col <- c("#7DB0DD","#86B875","#E495A5")
pairs(mydata[,-5], col = species_col[species_labels],
lower.panel = NULL, cex.labels=2, pch=19, cex = 1)
par(xpd = TRUE)
legend(x = 0.1, y = 0.4, cex = 1.2)
as.character(levels(species_labels))
species_col
pairs(mydata[,-5], col = species_col[species_labels],
lower.panel = NULL, cex.labels=2, pch=19, cex = 1)
#par(xpd = TRUE)
legend(x = 0.1, y = 0.4, cex = 1.2,legend = as.character(levels(species_labels)), fill = species_col)
legend(1, 95, legend=c("Line 1", "Line 2"),
col=c("red", "blue"), lty=1:2, cex=0.8)
#par(xpd = TRUE)
legend(x = 0.1, y = 0.4,legend = as.character(levels(species_labels)), fill = species_col)
#par(xpd = TRUE)
legend(x = 0.1, y = 0.1,legend = as.character(levels(species_labels)), fill = species_col)
#par(xpd = TRUE)
legend(x = 0.0, y = 0.0,legend = as.character(levels(species_labels)), fill = species_col)
#par(xpd = TRUE)
legend(x = 1.0, y  =95.0,legend = as.character(levels(species_labels)), fill = species_col)
#par(xpd = TRUE)
legend(
x = 1.0,
y = 95.0,
legend = as.character(levels(species_labels)),
fill = species_col)
#par(xpd = TRUE)
legend(
x = 0.5,
y = 0.5,
legend = as.character(levels(species_labels)),
fill = species_col)
as.character(levels(species_labels))
# https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html
MASS::parcoord(iris[,-5], col = species_col[species_labels], var.label = TRUE, lwd = 2)
# Add a legend
par(xpd = TRUE)
legend(x = 1.75, y = -.25, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
pairs(mydata[,-5], col = species_col[species_labels],
lower.panel = NULL, cex.labels=2, pch=19, cex = 1)
# "setosa"BLUE "versicolor"GREEN "virginica"RED
par(xpd = TRUE)
legend(
x = 0.5,
y = 0.5,
legend = as.character(levels(species_labels)),
fill = species_col)
# https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html
MASS::parcoord(iris[,-5], col = species_col[species_labels], var.label = TRUE, lwd = 2)
# Add a legend
par(xpd = TRUE)
legend(x = 0.75, y = -.25, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(x = 1.75, y = 0.25, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(x = 1.75, y = -0.15, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(x = 1.75, y = -0.7, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
# Add a legend
par(xpd = TRUE)
legend(x = 1.75, y = -0.7, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
# https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html
MASS::parcoord(iris[,-5], col = species_col[species_labels], var.label = TRUE, lwd = 2)
# Add a legend
par(xpd = TRUE)
legend(x = 1.75, y = -0.7, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(x = 1.75, y = -0.07, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(x = 1.75, y = -0.10, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(x = 1.75, y = -0.20, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(x = 1.75, y = -0.22, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
# https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html
MASS::parcoord(iris[,-5], col = species_col[species_labels], var.label = TRUE, lwd = 2)
# Add a legend
par(xpd = TRUE)
legend(x = 1.75, y = -0.22, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
species_labels <- mydata[,5]
species_col <- c("#7DB0DD","#86B875","#E495A5")
pairs(mydata[,-5], col = species_col[species_labels],
lower.panel = NULL, cex.labels=2, pch=19, cex = 1)
# "setosa"BLUE "versicolor"GREEN "virginica"RED
par(xpd = TRUE)
legend(x = 1.75, y = -0.22, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
myiris <- cbind(mydata,virginica=ifelse(mydata$Species=="virginica",1,0))
myiris$virginica
library(VGAM);
install.packages('VGAM', dependencies=TRUE);
library(VGAM);
myiris <- cbind(myiris,versicolor=ifelse(iris$Species=="versicolor",1,0))
myiris <- cbind(myiris,setosa=ifelse(iris$Species=="setosa",1,0))
head(myiris)
View(myiris)
iris.vglm <- vglm(cbind(virginica,versicolor,setosa) ~ Sepal.Length +
Sepal.Width + Petal.Length + Petal.Width, family=multinomial,
data=myiris)
summary(iris.vglm)
iris.vglm@predictors[71,]
c(sum(cbind(1,iris[71,1:4])*iris.vglm@coefficients[c(1,3,5,7,9)]),
sum(cbind(1,iris[71,1:4])*iris.vglm@coefficients[c(2,4,6,8,10)]))
iris.vglm@fitted.values[71,]
exp(lp71)/sum(exp(lp71))
lp71 <- as.vector(c(iris.vglm@predictors[71,],0))
exp(lp71)/sum(exp(lp71))
head(fitted(iris.vglm))
# Now we use 'fitted.iris' as the model-based classifications
# of which flower is of each type.  How does this compare
# to the real types?
rclass.iris <- ifelse(apply(abs(round(fitted(iris.vglm)) - myiris[,6:8]),1,sum)==0,1,0)
(1-mean(rclass.iris))*100
set.seed(1234) # labels are the original ones with this seed (avoid permutation)
r.km <- kmeans(iris[,1:4], centers=3)
mean(r.km$cluster!=as.numeric(iris$Species))*100
c0 <- list(r.km$centers[1,], r.km$centers[2,], r.km$centers[3,])
r.em <- mvnormalmixEM(iris[,1:4], mu=c0, arbvar=FALSE)
r.em$lambda
r.em$mu
r.em$sigma
post <- r.em$posterior
r.em$class <- sapply(seq(nrow(post)), function(i) { j <- which.max(as.vector(post[i,])) })
mean(r.em$class!=as.numeric(iris$Species))*100
source('~/MNT_ITESM_courses/1.1.Computacion_Aplicada/04_StadisticsAndStochasticProcesses/Homework3/Homework3.R', echo=TRUE)
library(ellipse);
library(ellipse);
library(gridExtra);
install.packages('gridExtra', dependencies=TRUE);
library(ellipse);
library(gridExtra);
detach(package:mixtools)
library(ellipse)
library(gridExtra)
Species <- levels(iris$Species)
j1=1;  j2=2
df_ell <- data.frame()
for(g in (1:3)){
#  M=r.em$sigma[[g]][c(j1,j2),c(j1,j2)]
M=r.em$sigma[c(j1,j2),c(j1,j2)]
c=r.em$mu[[g]][c(j1,j2)]
df_ell <- rbind(df_ell, cbind(as.data.frame(ellipse(M,centre=c, level=0.68)), group=Species[g]))
}
pl1 <- ggplot(data=iris) + geom_point(aes_string(x=iris[,j1],y=iris[,j2], colour=iris[,5])) +
theme(legend.position="none") +xlab(names(iris)[j1])+ylab(names(iris)[j2]) +
geom_path(data=df_ell, aes(x=x, y=y,color=group), size=1, linetype=1)
j1=3;  j2=4
df_ell <- data.frame()
for(g in (1:3)){
#  M=r.em$sigma[[g]][c(j1,j2),c(j1,j2)]
M=r.em$sigma[c(j1,j2),c(j1,j2)]
c=r.em$mu[[g]][c(j1,j2)]
df_ell <- rbind(df_ell, cbind(as.data.frame(ellipse(M,centre=c, level=0.68)), group=Species[g]))
}
pl2 <- ggplot(data=iris) + geom_point(aes_string(x=iris[,j1],y=iris[,j2], colour=iris[,5])) +
theme(legend.position="none") +xlab(names(iris)[j1])+ylab(names(iris)[j2]) +
geom_path(data=df_ell, aes(x=x, y=y,color=group), size=1, linetype=1)
grid.arrange(pl1, pl2)
View(iris.vglm@predictors)
View(fitted(iris.vglm))
# https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html
MASS::parcoord(mydata[,-5], col = species_col[species_labels], var.label = TRUE, lwd = 2)
# Add a legend
par(xpd = TRUE)
legend(  "bottom",
inset=.02, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(  "bottom",
inset=.01, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(  "bottom",
inset=0, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(  "bottom",
inset=-0.05, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(  "bottom",
inset=-1.05, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(  "bottom",
inset=-1.05, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(  "bottom",
inset=-0.5, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
# https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html
MASS::parcoord(mydata[,-5], col = species_col[species_labels], var.label = TRUE, lwd = 2)
# Add a legend
par(xpd = TRUE)
legend(  "bottom",
inset=-0.5, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
legend(  "bottom",
inset=-0.3, cex = 1,
legend = as.character(levels(species_labels)),
fill = species_col, horiz = TRUE)
species_col <- c("#7DB0DD","#86B875","#E495A5")
pairs(mydata[,-5], col = species_col[species_labels],
lower.panel = NULL, cex.labels=2, pch=19, cex = 1)
# "setosa"BLUE "versicolor"GREEN "virginica"RED
par(xpd = TRUE)
legend(
"bottomleft",
inset=0.0,
legend = as.character(levels(species_labels)),
fill = species_col)
legend(
"bottomleft",
inset=-1.0,
legend = as.character(levels(species_labels)),
fill = species_col)
legend(
"bottomleft",
inset=1.0,
legend = as.character(levels(species_labels)),
fill = species_col)
legend(
"bottomleft",
inset=0.02,
legend = as.character(levels(species_labels)),
fill = species_col)
legend(
"center",
legend = as.character(levels(species_labels)),
fill = species_col)
pairs(mydata[,-5], col = species_col[species_labels],
lower.panel = NULL, cex.labels=2, pch=19, cex = 1)
# "setosa"BLUE "versicolor"GREEN "virginica"RED
par(xpd = TRUE)
legend(
"center",
legend = as.character(levels(species_labels)),
fill = species_col)
