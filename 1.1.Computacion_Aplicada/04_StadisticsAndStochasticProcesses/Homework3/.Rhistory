# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
cor(mydata);
measurements =
mydata$Sepal.Length +
mydata$Sepal.Width +
mydata$Petal.Length +
mydata$Petal.Width;
hist(measurements)
# Gaussian Mixture Model (GMM)
# normalmixEM() K indica la cantidad de estados ocultos que queremos usar
# EM indica el uso del algoritmo de esperanza maximización
mixmdl <- normalmixEM(measurements,k=3);
summary(mixmdl); # lambda significa la proporción que hay en cada grupo
# mixtools sobreescribe la función plot
# Con el valor 2 indicamos que queremos imprimir las curvas de densidad
plot(mixmdl,whichplots = 2)
lines(density(measurements), lty=2, lwd=2)
# Análisis bidimensional
plot(measurements, mydata$Species)
mixmv <- mvnormalmixEM(measurements, k=3)
plot(mixmv , which = 2)
# Análisis bidimensional
plot(measurements, mydata$Species)
mixmv <- mvnormalmixEM(mydata,k=3)
mydata[-1]
mydata[-5]
mixmv <- mvnormalmixEM(mydata[-5],k=3)
plot(mixmv,which=2)
mixmv <- mvnormalmixEM(mydata[-5],k=3)
plot(mixmv,which=2)
summary(mixmv)
mixmv <- mvnormalmixEM(mydata$Species,k=3)
str(mixmv)
str(mydata)
str(measurements,mydata[5])
str(cbind(measurements,mydata[5])
str(cbind(measurements,mydata[5]))
str(cbind(measurements,mydata[5]))
mixmv <- mvnormalmixEM(cbind(measurements,mydata[5]),k=3)
#*******************************************************************************
#* PART 2 **********************************************************************
# Dataset: iris
# * It gives the measurements in centimeters of the variables sepal length and
#   width and petal length and width, respectively, for 50 flowers from each of
#   3 species of iris.
# * Use a GMM algorithm to cluster values into 3 classes
# * Independent variables: Sepal length and width, petal length and width
# * Return Confusion matrix of predicted class versus real class (Species)
# * Plot the answer (+10)
# * Independent variables or transformation of independent variables colored by
#   the predicted class
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
cor(mydata);
measurements =
mydata$Sepal.Length +
mydata$Sepal.Width +
mydata$Petal.Length +
mydata$Petal.Width;
hist(measurements)
# Gaussian Mixture Model (GMM)
# normalmixEM() K indica la cantidad de estados ocultos que queremos usar
# EM indica el uso del algoritmo de esperanza maximización
mixmdl <- normalmixEM(measurements,k=3);
summary(mixmdl); # lambda significa la proporción que hay en cada grupo
# mixtools sobreescribe la función plot
# Con el valor 2 indicamos que queremos imprimir las curvas de densidad
plot(mixmdl,whichplots=2)
lines(density(measurements), lty=2, lwd=2)
# Análisis bidimensional
plot(measurements, mydata$Species)
mixmv <- mvnormalmixEM(cbind(measurements,mydata[5]),k=3)
summary(mixmv)
plot(mixmv,which=2)
# Análisis bidimensional
plot(cbind(measurements,mydata[5]))
# Análisis bidimensional
plot(cbind(measurements,mydata[5]))
mixmv <- mvnormalmixEM(cbind(measurements,mydata[5]),k=3)
mixmv <- mvnormalmixEM(cbind(measurements,levels(mydata[5]),k=3)
mixmv <- mvnormalmixEM(cbind(measurements,levels(mydata[5]),k=3)
mixmv <- mvnormalmixEM(cbind(measurements,levels(mydata[5])),k=3)
levels(mydata[5])
mydata[5]
mixmv <- mvnormalmixEM(cbind(measurements,mydata[5]),k=3)
summary(mixmv)
mixmv <- mvnormalmixEM(mydata[-5],k=3)
summary(mixmv)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=1)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=2)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=3)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=3)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=4)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=5)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=6)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=6)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=8)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=3)
# 1. A plot of residuals against fitted values
# 2. A normal Q-Q plot
# 3. A Scale-Location plot of sqrt(| residuals |) against fitted values
# 4. A plot of Cook's distances versus row labels
# 5. A plot of residuals against leverages
# 6. A plot of Cook's distances against leverage/(1-leverage)
plot(mixmv,which=1)
summary(mixmv)
# Análisis bidimensional
plot(cbind(mydata[1],mydata[2]))
mixmv <- mvnormalmixEM(cbind(mydata[1],mydata[2]),k=3)
summary(mixmv)
plot(mixmv,which=2)
plot(mixmv,which=1)
plot(mixmv,which=2)
plot(mixmv,which=3)
plot(mixmv,which=4)
plot(mixmv,which=2)
plot(mixmv,which=2)
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
# Análisis bidimensional
plot(measurements,as.Numeric(mydata[5]))
# Análisis bidimensional
plot(measurements,as.numeric(mydata[5]))
as.numeric(mydata[5])
str(mydata[5])
levels(mydata[5])
level(mydata[5])
factor(mydata[5])
factor(as.factor(mydata[5]))
as.numeric(factor(mydata[5]))
mydata[5]
as.factor(mydata[5])
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
#There is data from 3 Species
#Let's convert the Species data into a factor
mydata$Species = factor(as.numeric(mydata$Species))
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
cor(mydata);
#There is data from 3 Species
#Let's convert the Species data into a factor
mydata$Species = factor(as.numeric(mydata$Species),"a","b","c")
# Let's take a look to the data ...
str(mydata);
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
#There is data from 3 Species
#Let's convert the Species data into a factor
mydata$Species = factor(as.numeric(mydata$Species),"a","b","c")
# Let's take a look to the data ...
str(mydata);
summary(mydata);
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
#There is data from 3 Species
#Let's convert the Species data into a factor
mydata$Species = factor(as.numeric(mydata$Species))
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
cor(mydata);
cor(as.numeric(mydata));
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
cor(mydata);
#There is data from 3 Species
#Let's convert the Species data into a factor
mydata$Species = factor(as.numeric(mydata$Species))
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
cor(mydata);
#There is data from 3 Species
#Let's convert the Species data into a factor
mydata$Species = factor(as.numeric(mydata$Species))
measurements =
mydata$Sepal.Length +
mydata$Sepal.Width +
mydata$Petal.Length +
mydata$Petal.Width;
hist(measurements)
# Gaussian Mixture Model (GMM)
# normalmixEM() K indica la cantidad de estados ocultos que queremos usar
# EM indica el uso del algoritmo de esperanza maximización
mixmdl <- normalmixEM(measurements,k=3);
summary(mixmdl); # lambda significa la proporción que hay en cada grupo
# mixtools sobreescribe la función plot
# Con el valor 2 indicamos que queremos imprimir las curvas de densidad
plot(mixmdl,whichplots=2)
lines(density(measurements), lty=2, lwd=2)
# Análisis bidimensional
plot(measurements,as.numeric(mydata$Species))
mixmv <- mvnormalmixEM(measurements,as.numeric(mydata$Species),k=3)
mixmv <- mvnormalmixEM(cbind(measurements,as.numeric(mydata$Species)),k=3)
# Análisis bidimensional
plot(measurements,as.numeric(mydata$Species))
mixmv <- mvnormalmixEM(cbind(measurements,as.numeric(mydata$Species)),k=3)
summary(mixmv)
plot(mixmv,which=2)
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
#cor(mydata);
#There is data from 3 Species
#Let's convert the Species data into a factor
# 1:setosa
# 2:versicolor
# 3:virginica
mydata$Species = factor(as.numeric(mydata$Species))
measurements =
mydata$Sepal.Length +
mydata$Sepal.Width +
mydata$Petal.Length +
mydata$Petal.Width;
hist(measurements)
# Gaussian Mixture Model (GMM)
# normalmixEM() K indica la cantidad de estados ocultos que queremos usar
# EM indica el uso del algoritmo de esperanza maximización
mixmdl <- normalmixEM(measurements,k=3);
summary(mixmdl); # lambda significa la proporción que hay en cada grupo
# mixtools sobreescribe la función plot
# Con el valor 2 indicamos que queremos imprimir las curvas de densidad
plot(mixmdl,whichplots=2)
lines(density(measurements), lty=2, lwd=2)
# Análisis bidimensional
plot(measurements,as.numeric(mydata$Species))
mixmv <- mvnormalmixEM(cbind(measurements,as.numeric(mydata$Species)),k=3)
summary(mixmv)
plot(mixmv,which=2)
cbind(measurements,as.numeric(mydata$Species)
colBind = cbind(measurements,as.numeric(mydata$Species)
colBind = cbind(measurements,as.numeric(mydata$Species))
View(colBind)
mixmv <- mvnormalmixEM(colBind,k=3)
# Análisis bidimensional
plot(measurements,as.numeric(mydata$Species))
colBind = cbind(measurements,as.numeric(mydata$Species))
View(colBind)
mixmv <- mvnormalmixEM(measurements,k=3)
View(colBind)
colBind = as.dataframe(cbind(measurements,as.numeric(mydata$Species)))
class(iris)
colBind = as.data.frame(cbind(measurements,as.numeric(mydata$Species)))
View(colBind)
mixmv <- mvnormalmixEM(measurements,k=3)
data(faithful)
data(faithful)
wait = faithful$waiting
mixmv <- mvnormalmixEM(faithful, k = 2)
plot(mixmv , which = 2)
# Análisis bidimensional
plot(faithful$eruptions, faithful$waiting)
mixmv <- mvnormalmixEM(faithful, k = 2)
mixmv <- mvnormalmixEM(faithful, k = 2)
mixmv <- mvnormalmixEM(measurements,k=3)
mixmv <- mvnormalmixEM(measurements,k=2)
mixmv <- mvnormalmixEM(colBind,k=3)
mixmv <- mvnormalmixEM(faithful, k = 2)
mixmv <- mvnormalmixEM(faithful, k = 2)
mixmv <- mvnormalmixEM(colBind,k=3)
# Análisis bidimensional
plot(colBind)
# Análisis bidimensional
colBind = as.data.frame(cbind(measurements,mydata$Species))
plot(colBind)
mixmv <- mvnormalmixEM(faithful, k = 2)
mixmv <- mvnormalmixEM(colBind,k=3)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(colBind);
# remove rows with incomplete data
colBind = colBind[completeData,];
plot(colBind)
mixmv <- mvnormalmixEM(colBind,k=3)
View(colBind)
View(faithful)
# Análisis bidimensional
colBind = as.data.frame(cbind(measurements,mydata$Species))
names(colBind) <- c("measurements","Species")
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(colBind);
# remove rows with incomplete data
colBind = colBind[completeData,];
names(colBind) <- c("measurements","Species")
plot(colBind)
mixmv <- mvnormalmixEM(colBind,k=3)
library(mclust)
install.packages('mclust', dependencies=TRUE);
library(mclust);
mb = Mclust(iris[,-5])
#or specify number of clusters
mb3 = Mclust(iris[,-5], 3)
# optimal selected model
mb$modelName
# optimal number of cluster
mb$G
# probality for an observation to be in a given cluster
head(mb$z)
# get probabilities, means, variances
summary(mb, parameters = TRUE)
# Compare amount of the data within each cluster
table(iris$Species, mb$classification)
# vs
table(iris$Species, mb3$classification)
# After the data is fit into the model, we plot the model based on clustering results.
plot(mb, what=c("classification"))
# After the data is fit into the model, we plot the model based on clustering results.
plot(mb, "classification")
# Let's plot estimated density. Contour plot
plot(mb, "density")
# You can also use the summary() function to obtain the most likely model and the most possible number of clusters. For this example, the most possible number of clusters is five, with a BIC value equal to -556.1142.
summary(mb)
# optimal selected model
mb$modelName
mb = Mclust(mydata[,-5])
#or specify number of clusters
mb3 = Mclust(mydata[,-5], 3)
# optimal selected model
mb3$modelName
# optimal number of cluster
mb3$G
# probality for an observation to be in a given cluster
head(mb3$z)
# get probabilities, means, variances
summary(mb3, parameters = TRUE)
# Compare amount of the data within each cluster
table(iris$Species, mb$classification)
# vs
table(iris$Species, mb3$classification)
# After the data is fit into the model, we plot the model based on clustering results.
plot(mb3, "classification")
# The types of what argument are: "BIC", "classification", "uncertainty", "density". By default, all the above graphs are produced.
# Let's plot estimated density. Contour plot
plot(mb3, "density")
# You can also use the summary() function to obtain the most likely model and the most possible number of clusters. For this example, the most possible number of clusters is five, with a BIC value equal to -556.1142.
summary(mb3)
# * Independent variables or transformation of independent variables colored by
#   the predicted class
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
str(mydata);
summary(mydata);
pairs(mydata);
#cor(mydata);
###########################
mb = Mclust(mydata[,-5])
#or specify number of clusters
mb3 = Mclust(mydata[,-5], 3)
# optimal selected model
mb3$modelName
# optimal number of cluster
mb3$G
# probality for an observation to be in a given cluster
head(mb3$z)
# get probabilities, means, variances
summary(mb3, parameters = TRUE)
# Compare amount of the data within each cluster
table(iris$Species, mb$classification)
# vs
table(iris$Species, mb3$classification)
# After the data is fit into the model, we plot the model based on clustering results.
plot(mb3, "classification")
# The types of what argument are: "BIC", "classification", "uncertainty", "density". By default, all the above graphs are produced.
# Let's plot estimated density. Contour plot
plot(mb3, "density")
# You can also use the summary() function to obtain the most likely model and the most possible number of clusters. For this example, the most possible number of clusters is five, with a BIC value equal to -556.1142.
summary(mb3)
plot(mb3)
plot(mb3, "BIC")
plot(mb3, "uncertainty")
# You can also use the summary() function to obtain the most likely model and the most possible number of clusters. For this example, the most possible number of clusters is five, with a BIC value equal to -556.1142.
summary(mb3)
# You can also use the summary() function to obtain the most likely model and the most possible number of clusters. For this example, the most possible number of clusters is five, with a BIC value equal to -556.1142.
summary(mb)
# You can also use the summary() function to obtain the most likely model and the most possible number of clusters. For this example, the most possible number of clusters is five, with a BIC value equal to -556.1142.
summary(mb3)
