r.km <- kmeans(species_data, centers=3)
mean(r.km$cluster!=as.numeric(mydata$Species))*100
# Let us know fit a mixture of three multidimensional Gaussian distributions.
# The model assumes the same variance covariance matrix for the three
# distributions (arbvar=FALSE). Initial centers are those given by the kmeans
# procedure.
library(mixtools)
c0 <- list(r.km$centers[1,], r.km$centers[2,], r.km$centers[3,])
mixmdl <- mvnormalmixEM(species_data, mu=c0, arbvar=FALSE)
summary(mixmdl) # lambda is the proportion of each cluster
# Fitting mixtures - get confusion matrix
pred <- apply(mixmdl$posterior, 1, function(row) which.max(row))
pred <- mapvalues(pred,
from = c("1", "2", "3"),
to   = c("setosa", "versicolor", "virginica"))
table(species_labels, pred)
#CLUSTER PLOTS#
detach(package:mixtools)
plotClusters <- function(j1,j2){
Species <- levels(mydata$Species)
df_ell <- data.frame()
for(g in (1:3)){
M=mixmdl$sigma[c(j1,j2),c(j1,j2)]
c=mixmdl$mu[[g]][c(j1,j2)]
df_ell <- rbind(df_ell, cbind(as.data.frame(ellipse(
M,
centre=c,
level=0.68)), group=Species[g]))
}
pl0 <- ggplot(data=mydata) +
geom_point(aes_string(x=mydata[,j1],y=mydata[,j2], colour=species_labels))+
theme(legend.position="bottom")+
xlab(names(mydata)[j1])+
ylab(names(mydata)[j2])+
geom_path(data=df_ell, aes(x=x, y=y,color=group), size=1, linetype=1)
return(pl0)
}
pl1 <- plotClusters(2,1) # Sepal.Width  vs Sepal.Length
pl2 <- plotClusters(3,1) # Petal.Length vs Sepal.Length
pl3 <- plotClusters(4,1) # Petal.Width  vs Sepal.Length
pl4 <- plotClusters(3,2) # Petal.Length vs Sepal.Width
pl5 <- plotClusters(4,2) # Petal.Width  vs Sepal.Width
pl6 <- plotClusters(4,3) # Petal.Width  vs Petal.Length
grid.arrange(pl1,pl2,pl3,pl4,pl5,pl6, layout_matrix=rbind(c(1,2,3),c(4,5,6)))
#DENSITY PLOTS#
plotDensities <- function(n){
pl0 <- ggplot(mydata, aes(x=mydata[,n], color=Species, fill=Species))+
geom_histogram(aes(y=..density..), alpha=0.5, position="identity")+
geom_density(alpha=.2)+
labs(title=names(mydata)[n],x="Value", y = "Density")
return(pl0)
}
pl1 <- plotDensities(1)
pl2 <- plotDensities(2)
pl3 <- plotDensities(3)
pl4 <- plotDensities(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
#BOX PLOTS#
plotBoxes <- function(n){
pl0 <- ggplot(data=mydata, aes(x=Species, y=mydata[,n], color=Species))+
geom_boxplot()+
labs(title=names(mydata)[n],x="Species", y = "Value")+
theme(legend.position="none")
return(pl0)
}
pl1 <- plotBoxes(1)
pl2 <- plotBoxes(2)
pl3 <- plotBoxes(3)
pl4 <- plotBoxes(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
# Install required libraries
install.packages('e1071', dependencies=TRUE);
install.packages('caret', dependencies=TRUE);
install.packages("caret", dependencies = TRUE)
install.packages('mixtools', dependencies=TRUE);
install.packages('mclust', dependencies=TRUE);
install.packages('BSDA', dependencies=TRUE);
install.packages('VGAM', dependencies=TRUE);
install.packages('psych', dependencies=TRUE);
# Load required libraries
library(caret);
library(datasets);
library(mclust);
library(ggplot2);
library(dplyr);
library(VGAM);
library(ellipse);
library(gridExtra);
library(psych);
install.packages("gridExtra")
library(gridExtra);
install.packages("mclust")
library(mclust);
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
species_labels <- mydata[,5]
species_data <- mydata[,-5]
species_col <- c("#7DB0DD","#86B875","#E495A5")
# Ignoring the known labels (species) of the Fisher Iris data, let us identify
# three clusters with the k-means method and compute the missclassification rate
set.seed(1234)
# labels are the original ones with this seed (avoid permutation)
r.km <- kmeans(species_data, centers=3)
mean(r.km$cluster!=as.numeric(mydata$Species))*100
# Let us know fit a mixture of three multidimensional Gaussian distributions.
# The model assumes the same variance covariance matrix for the three
# distributions (arbvar=FALSE). Initial centers are those given by the kmeans
# procedure.
library(mixtools)
c0 <- list(r.km$centers[1,], r.km$centers[2,], r.km$centers[3,])
mixmdl <- mvnormalmixEM(species_data, mu=c0, arbvar=FALSE)
summary(mixmdl) # lambda is the proportion of each cluster
# Fitting mixtures - get confusion matrix
pred <- apply(mixmdl$posterior, 1, function(row) which.max(row))
pred <- mapvalues(pred,
from = c("1", "2", "3"),
to   = c("setosa", "versicolor", "virginica"))
table(species_labels, pred)
#CLUSTER PLOTS#
detach(package:mixtools)
plotClusters <- function(j1,j2){
Species <- levels(mydata$Species)
df_ell <- data.frame()
for(g in (1:3)){
M=mixmdl$sigma[c(j1,j2),c(j1,j2)]
c=mixmdl$mu[[g]][c(j1,j2)]
df_ell <- rbind(df_ell, cbind(as.data.frame(ellipse(
M,
centre=c,
level=0.68)), group=Species[g]))
}
pl0 <- ggplot(data=mydata) +
geom_point(aes_string(x=mydata[,j1],y=mydata[,j2], colour=species_labels))+
theme(legend.position="bottom")+
xlab(names(mydata)[j1])+
ylab(names(mydata)[j2])+
geom_path(data=df_ell, aes(x=x, y=y,color=group), size=1, linetype=1)
return(pl0)
}
pl1 <- plotClusters(2,1) # Sepal.Width  vs Sepal.Length
pl2 <- plotClusters(3,1) # Petal.Length vs Sepal.Length
pl3 <- plotClusters(4,1) # Petal.Width  vs Sepal.Length
pl4 <- plotClusters(3,2) # Petal.Length vs Sepal.Width
pl5 <- plotClusters(4,2) # Petal.Width  vs Sepal.Width
pl6 <- plotClusters(4,3) # Petal.Width  vs Petal.Length
grid.arrange(pl1,pl2,pl3,pl4,pl5,pl6, layout_matrix=rbind(c(1,2,3),c(4,5,6)))
#DENSITY PLOTS#
plotDensities <- function(n){
pl0 <- ggplot(mydata, aes(x=mydata[,n], color=Species, fill=Species))+
geom_histogram(aes(y=..density..), alpha=0.5, position="identity")+
geom_density(alpha=.2)+
labs(title=names(mydata)[n],x="Value", y = "Density")
return(pl0)
}
pl1 <- plotDensities(1)
pl2 <- plotDensities(2)
pl3 <- plotDensities(3)
pl4 <- plotDensities(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
#BOX PLOTS#
plotBoxes <- function(n){
pl0 <- ggplot(data=mydata, aes(x=Species, y=mydata[,n], color=Species))+
geom_boxplot()+
labs(title=names(mydata)[n],x="Species", y = "Value")+
theme(legend.position="none")
return(pl0)
}
pl1 <- plotBoxes(1)
pl2 <- plotBoxes(2)
pl3 <- plotBoxes(3)
pl4 <- plotBoxes(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
#CLUSTER PLOTS#
detach(package:mixtools)
?detach
#CLUSTER PLOTS#
plotClusters <- function(j1,j2){
Species <- levels(mydata$Species)
df_ell <- data.frame()
for(g in (1:3)){
M=mixmdl$sigma[c(j1,j2),c(j1,j2)]
c=mixmdl$mu[[g]][c(j1,j2)]
df_ell <- rbind(df_ell, cbind(as.data.frame(ellipse(
M,
centre=c,
level=0.68)), group=Species[g]))
}
pl0 <- ggplot(data=mydata) +
geom_point(aes_string(x=mydata[,j1],y=mydata[,j2], colour=species_labels))+
theme(legend.position="bottom")+
xlab(names(mydata)[j1])+
ylab(names(mydata)[j2])+
geom_path(data=df_ell, aes(x=x, y=y,color=group), size=1, linetype=1)
return(pl0)
}
pl1 <- plotClusters(2,1) # Sepal.Width  vs Sepal.Length
pl2 <- plotClusters(3,1) # Petal.Length vs Sepal.Length
pl3 <- plotClusters(4,1) # Petal.Width  vs Sepal.Length
pl4 <- plotClusters(3,2) # Petal.Length vs Sepal.Width
pl5 <- plotClusters(4,2) # Petal.Width  vs Sepal.Width
pl6 <- plotClusters(4,3) # Petal.Width  vs Petal.Length
grid.arrange(pl1,pl2,pl3,pl4,pl5,pl6, layout_matrix=rbind(c(1,2,3),c(4,5,6)))
#DENSITY PLOTS#
plotDensities <- function(n){
pl0 <- ggplot(mydata, aes(x=mydata[,n], color=Species, fill=Species))+
geom_histogram(aes(y=..density..), alpha=0.5, position="identity")+
geom_density(alpha=.2)+
labs(title=names(mydata)[n],x="Value", y = "Density")
return(pl0)
}
pl1 <- plotDensities(1)
pl2 <- plotDensities(2)
pl3 <- plotDensities(3)
pl4 <- plotDensities(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
#BOX PLOTS#
plotBoxes <- function(n){
pl0 <- ggplot(data=mydata, aes(x=Species, y=mydata[,n], color=Species))+
geom_boxplot()+
labs(title=names(mydata)[n],x="Species", y = "Value")+
theme(legend.position="none")
return(pl0)
}
pl1 <- plotBoxes(1)
pl2 <- plotBoxes(2)
pl3 <- plotBoxes(3)
pl4 <- plotBoxes(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
View(iris)
?set.seed
#CLUSTER PLOTS#
plotClusters <- function(j1,j2){
Species <- levels(mydata$Species)
df_ell <- data.frame()
for(g in (1:3)){
M=mixmdl$sigma[c(j1,j2),c(j1,j2)]
c=mixmdl$mu[[g]][c(j1,j2)]
df_ell <- rbind(df_ell, cbind(as.data.frame(ellipse(
M,
centre=c,
level=0.68)), group=Species[g]))
}
pl0 <- ggplot(data=mydata) +
geom_point(aes_string(x=mydata[,j1],y=mydata[,j2], colour=species_labels))+
theme(legend.position="bottom")+
xlab(names(mydata)[j1])+
ylab(names(mydata)[j2])+
geom_path(data=df_ell, aes(x=x, y=y,color=group), size=1, linetype=1)
return(pl0)
}
pl1 <- plotClusters(2,1) # Sepal.Width  vs Sepal.Length
pl2 <- plotClusters(3,1) # Petal.Length vs Sepal.Length
pl3 <- plotClusters(4,1) # Petal.Width  vs Sepal.Length
pl4 <- plotClusters(3,2) # Petal.Length vs Sepal.Width
pl5 <- plotClusters(4,2) # Petal.Width  vs Sepal.Width
pl6 <- plotClusters(4,3) # Petal.Width  vs Petal.Length
grid.arrange(pl1,pl2,pl3,pl4,pl5,pl6, layout_matrix=rbind(c(1,2,3),c(4,5,6)))
#DENSITY PLOTS#
plotDensities <- function(n){
pl0 <- ggplot(mydata, aes(x=mydata[,n], color=Species, fill=Species))+
geom_histogram(aes(y=..density..), alpha=0.5, position="identity")+
geom_density(alpha=.2)+
labs(title=names(mydata)[n],x="Value", y = "Density")
return(pl0)
}
pl1 <- plotDensities(1)
pl2 <- plotDensities(2)
pl3 <- plotDensities(3)
pl4 <- plotDensities(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
#BOX PLOTS#
plotBoxes <- function(n){
pl0 <- ggplot(data=mydata, aes(x=Species, y=mydata[,n], color=Species))+
geom_boxplot()+
labs(title=names(mydata)[n],x="Species", y = "Value")+
theme(legend.position="none")
return(pl0)
}
pl1 <- plotBoxes(1)
pl2 <- plotBoxes(2)
pl3 <- plotBoxes(3)
pl4 <- plotBoxes(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
# Install required libraries
# install.packages('e1071', dependencies=TRUE);
# install.packages('caret', dependencies=TRUE);
# install.packages('mixtools', dependencies=TRUE);
# install.packages('mclust', dependencies=TRUE);
# install.packages('BSDA', dependencies=TRUE);
# install.packages('VGAM', dependencies=TRUE);
install.packages('psych', dependencies=TRUE);
install.packages("psych", dependencies = TRUE)
library(psych);
c0 <- list(r.km$centers[1,], r.km$centers[2,], r.km$centers[3,])
mixmdl <- mvnormalmixEM(species_data, mu=c0, arbvar=FALSE)
# Let us know fit a mixture of three multidimensional Gaussian distributions.
# The model assumes the same variance covariance matrix for the three
# distributions (arbvar=FALSE). Initial centers are those given by the kmeans
# procedure.
library(mixtools)
c0 <- list(r.km$centers[1,], r.km$centers[2,], r.km$centers[3,])
mixmdl <- mvnormalmixEM(species_data, mu=c0, arbvar=FALSE)
summary(mixmdl) # lambda is the proportion of each cluster
# Fitting mixtures - get confusion matrix
pred <- apply(mixmdl$posterior, 1, function(row) which.max(row))
pred <- mapvalues(pred,
from = c("1", "2", "3"),
to   = c("setosa", "versicolor", "virginica"))
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
species_labels <- mydata[,5]
species_data <- mydata[,-5]
species_col <- c("#7DB0DD","#86B875","#E495A5")
# Ignoring the known labels (species) of the Fisher Iris data, let us identify
# three clusters with the k-means method and compute the missclassification rate
set.seed(1234)
species_data <- mydata[,-5]
species_col <- c("#7DB0DD","#86B875","#E495A5")
# Ignoring the known labels (species) of the Fisher Iris data, let us identify
# three clusters with the k-means method and compute the missclassification rate
set.seed(1234)
# labels are the original ones with this seed (avoid permutation)
r.km <- kmeans(species_data, centers=3)
mean(r.km$cluster!=as.numeric(mydata$Species))*100
# Let us know fit a mixture of three multidimensional Gaussian distributions.
# The model assumes the same variance covariance matrix for the three
# distributions (arbvar=FALSE). Initial centers are those given by the kmeans
# procedure.
library(mixtools)
c0 <- list(r.km$centers[1,], r.km$centers[2,], r.km$centers[3,])
mixmdl <- mvnormalmixEM(species_data, mu=c0, arbvar=FALSE)
summary(mixmdl) # lambda is the proportion of each cluster
# Fitting mixtures - get confusion matrix
pred <- apply(mixmdl$posterior, 1, function(row) which.max(row))
pred <- mapvalues(pred,
from = c("1", "2", "3"),
to   = c("setosa", "versicolor", "virginica"))
?mapvalues
table(species_labels, pred)
View(iris)
View(iris)
#CLUSTER PLOTS#
plotClusters <- function(j1,j2){
Species <- levels(mydata$Species)
df_ell <- data.frame()
for(g in (1:3)){
M=mixmdl$sigma[c(j1,j2),c(j1,j2)]
c=mixmdl$mu[[g]][c(j1,j2)]
df_ell <- rbind(df_ell, cbind(as.data.frame(ellipse(
M,
centre=c,
level=0.68)), group=Species[g]))
}
pl0 <- ggplot(data=mydata) +
geom_point(aes_string(x=mydata[,j1],y=mydata[,j2], colour=species_labels))+
theme(legend.position="bottom")+
xlab(names(mydata)[j1])+
ylab(names(mydata)[j2])+
geom_path(data=df_ell, aes(x=x, y=y,color=group), size=1, linetype=1)
return(pl0)
}
pl1 <- plotClusters(2,1) # Sepal.Width  vs Sepal.Length
pl2 <- plotClusters(3,1) # Petal.Length vs Sepal.Length
pl3 <- plotClusters(4,1) # Petal.Width  vs Sepal.Length
pl4 <- plotClusters(3,2) # Petal.Length vs Sepal.Width
pl5 <- plotClusters(4,2) # Petal.Width  vs Sepal.Width
#CLUSTER PLOTS#
detach(package:mixtools)
plotClusters <- function(j1,j2){
Species <- levels(mydata$Species)
df_ell <- data.frame()
for(g in (1:3)){
M=mixmdl$sigma[c(j1,j2),c(j1,j2)]
c=mixmdl$mu[[g]][c(j1,j2)]
df_ell <- rbind(df_ell, cbind(as.data.frame(ellipse(
M,
centre=c,
level=0.68)), group=Species[g]))
}
pl0 <- ggplot(data=mydata) +
geom_point(aes_string(x=mydata[,j1],y=mydata[,j2], colour=species_labels))+
theme(legend.position="bottom")+
xlab(names(mydata)[j1])+
ylab(names(mydata)[j2])+
geom_path(data=df_ell, aes(x=x, y=y,color=group), size=1, linetype=1)
return(pl0)
}
pl1 <- plotClusters(2,1) # Sepal.Width  vs Sepal.Length
pl2 <- plotClusters(3,1) # Petal.Length vs Sepal.Length
pl1 <- plotClusters(2,1) # Sepal.Width  vs Sepal.Length
function (x, row.names = NULL, optional = FALSE, ...)
{
if (is.null(x))
return(as.data.frame(list()))
UseMethod("as.data.frame")
}
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
species_labels <- mydata[,5]
species_data <- mydata[,-5]
library(caret);
library(datasets);
library(mclust);
library(ggplot2);
library(dplyr);
library(VGAM);
library(ellipse);
library(gridExtra);
library(psych);
# Load the iris dataset
data(iris)
# complete.cases() returns a logical vector with the value TRUE for rows that
# are complete, and FALSE for rows that have some NA values
completeData = complete.cases(iris);
# remove rows with incomplete data
mydata = iris[completeData,];
# Let's take a look to the data ...
species_labels <- mydata[,5]
species_data <- mydata[,-5]
species_col <- c("#7DB0DD","#86B875","#E495A5")
# Ignoring the known labels (species) of the Fisher Iris data, let us identify
# three clusters with the k-means method and compute the missclassification rate
set.seed(1234)
# labels are the original ones with this seed (avoid permutation)
r.km <- kmeans(species_data, centers=3)
mean(r.km$cluster!=as.numeric(mydata$Species))*100
# Let us know fit a mixture of three multidimensional Gaussian distributions.
# The model assumes the same variance covariance matrix for the three
# distributions (arbvar=FALSE). Initial centers are those given by the kmeans
# procedure.
library(mixtools)
c0 <- list(r.km$centers[1,], r.km$centers[2,], r.km$centers[3,])
mixmdl <- mvnormalmixEM(species_data, mu=c0, arbvar=FALSE)
summary(mixmdl) # lambda is the proportion of each cluster
# Fitting mixtures - get confusion matrix
pred <- apply(mixmdl$posterior, 1, function(row) which.max(row))
pred <- mapvalues(pred,
from = c("1", "2", "3"),
to   = c("setosa", "versicolor", "virginica"))
table(species_labels, pred)
#CLUSTER PLOTS#
detach(package:mixtools)
plotClusters <- function(j1,j2){
Species <- levels(mydata$Species)
df_ell <- data.frame()
for(g in (1:3)){
M=mixmdl$sigma[c(j1,j2),c(j1,j2)]
c=mixmdl$mu[[g]][c(j1,j2)]
df_ell <- rbind(df_ell, cbind(as.data.frame(ellipse(
M,
centre=c,
level=0.68)), group=Species[g]))
}
pl0 <- ggplot(data=mydata) +
geom_point(aes_string(x=mydata[,j1],y=mydata[,j2], colour=species_labels))+
theme(legend.position="bottom")+
xlab(names(mydata)[j1])+
ylab(names(mydata)[j2])+
geom_path(data=df_ell, aes(x=x, y=y,color=group), size=1, linetype=1)
return(pl0)
}
pl1 <- plotClusters(2,1) # Sepal.Width  vs Sepal.Length
pl2 <- plotClusters(3,1) # Petal.Length vs Sepal.Length
pl3 <- plotClusters(4,1) # Petal.Width  vs Sepal.Length
pl4 <- plotClusters(3,2) # Petal.Length vs Sepal.Width
pl5 <- plotClusters(4,2) # Petal.Width  vs Sepal.Width
pl6 <- plotClusters(4,3) # Petal.Width  vs Petal.Length
grid.arrange(pl1,pl2,pl3,pl4,pl5,pl6, layout_matrix=rbind(c(1,2,3),c(4,5,6)))
#DENSITY PLOTS#
plotDensities <- function(n){
pl0 <- ggplot(mydata, aes(x=mydata[,n], color=Species, fill=Species))+
geom_histogram(aes(y=..density..), alpha=0.5, position="identity")+
geom_density(alpha=.2)+
labs(title=names(mydata)[n],x="Value", y = "Density")
return(pl0)
}
pl1 <- plotDensities(1)
pl2 <- plotDensities(2)
pl3 <- plotDensities(3)
pl4 <- plotDensities(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
#BOX PLOTS#
plotBoxes <- function(n){
pl0 <- ggplot(data=mydata, aes(x=Species, y=mydata[,n], color=Species))+
geom_boxplot()+
labs(title=names(mydata)[n],x="Species", y = "Value")+
theme(legend.position="none")
return(pl0)
}
pl1 <- plotBoxes(1)
pl2 <- plotBoxes(2)
pl3 <- plotBoxes(3)
pl4 <- plotBoxes(4)
grid.arrange(pl1,pl2,pl3,pl4, layout_matrix=rbind(c(1,2),c(3,4)))
